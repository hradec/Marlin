V// source: plugin/systemcommandeditor/js/jquery.ui.sortable.js\u000a/*! jQuery UI - v1.9.2 - 2015-06-04\u000a* http://jqueryui.com\u000a* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.sortable.js\u000a* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\u000a\u000a(function( $, undefined ) {\u000a\u000avar uuid = 0,\u000a	runiqueId = /^ui-id-\u005cd+$/;\u000a\u000a// prevent duplicate loading\u000a// this is only a problem because we proxy existing functions\u000a// and we don't want to double proxy them\u000a$.ui = $.ui || {};\u000aif ( $.ui.version ) {\u000a	return;\u000a}\u000a\u000a$.extend( $.ui, {\u000a	version: "1.9.2",\u000a\u000a	keyCode: {\u000a		BACKSPACE: 8,\u000a		COMMA: 188,\u000a		DELETE: 46,\u000a		DOWN: 40,\u000a		END: 35,\u000a		ENTER: 13,\u000a		ESCAPE: 27,\u000a		HOME: 36,\u000a		LEFT: 37,\u000a		NUMPAD_ADD: 107,\u000a		NUMPAD_DECIMAL: 110,\u000a		NUMPAD_DIVIDE: 111,\u000a		NUMPAD_ENTER: 108,\u000a		NUMPAD_MULTIPLY: 106,\u000a		NUMPAD_SUBTRACT: 109,\u000a		PAGE_DOWN: 34,\u000a		PAGE_UP: 33,\u000a		PERIOD: 190,\u000a		RIGHT: 39,\u000a		SPACE: 32,\u000a		TAB: 9,\u000a		UP: 38\u000a	}\u000a});\u000a\u000a// plugins\u000a$.fn.extend({\u000a	_focus: $.fn.focus,\u000a	focus: function( delay, fn ) {\u000a		return typeof delay === "number" ?\u000a			this.each(function() {\u000a				var elem = this;\u000a				setTimeout(function() {\u000a					$( elem ).focus();\u000a					if ( fn ) {\u000a						fn.call( elem );\u000a					}\u000a				}, delay );\u000a			}) :\u000a			this._focus.apply( this, arguments );\u000a	},\u000a\u000a	scrollParent: function() {\u000a		var scrollParent;\u000a		if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {\u000a			scrollParent = this.parents().filter(function() {\u000a				return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));\u000a			}).eq(0);\u000a		} else {\u000a			scrollParent = this.parents().filter(function() {\u000a				return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));\u000a			}).eq(0);\u000a		}\u000a\u000a		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;\u000a	},\u000a\u000a	zIndex: function( zIndex ) {\u000a		if ( zIndex !== undefined ) {\u000a			return this.css( "zIndex", zIndex );\u000a		}\u000a\u000a		if ( this.length ) {\u000a			var elem = $( this[ 0 ] ), position, value;\u000a			while ( elem.length && elem[ 0 ] !== document ) {\u000a				// Ignore z-index if position is set to a value where z-index is ignored by the browser\u000a				// This makes behavior of this function consistent across browsers\u000a				// WebKit always returns auto if the element is positioned\u000a				position = elem.css( "position" );\u000a				if ( position === "absolute" || position === "relative" || position === "fixed" ) {\u000a					// IE returns 0 when zIndex is not specified\u000a					// other browsers return a string\u000a					// we ignore the case of nested elements with an explicit value of 0\u000a					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>\u000a					value = parseInt( elem.css( "zIndex" ), 10 );\u000a					if ( !isNaN( value ) && value !== 0 ) {\u000a						return value;\u000a					}\u000a				}\u000a				elem = elem.parent();\u000a			}\u000a		}\u000a\u000a		return 0;\u000a	},\u000a\u000a	uniqueId: function() {\u000a		return this.each(function() {\u000a			if ( !this.id ) {\u000a				this.id = "ui-id-" + (++uuid);\u000a			}\u000a		});\u000a	},\u000a\u000a	removeUniqueId: function() {\u000a		return this.each(function() {\u000a			if ( runiqueId.test( this.id ) ) {\u000a				$( this ).removeAttr( "id" );\u000a			}\u000a		});\u000a	}\u000a});\u000a\u000a// selectors\u000afunction focusable( element, isTabIndexNotNaN ) {\u000a	var map, mapName, img,\u000a		nodeName = element.nodeName.toLowerCase();\u000a	if ( "area" === nodeName ) {\u000a		map = element.parentNode;\u000a		mapName = map.name;\u000a		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {\u000a			return false;\u000a		}\u000a		img = $( "img[usemap=#" + mapName + "]" )[0];\u000a		return !!img && visible( img );\u000a	}\u000a	return ( /input|select|textarea|button|object/.test( nodeName ) ?\u000a		!element.disabled :\u000a		"a" === nodeName ?\u000a			element.href || isTabIndexNotNaN :\u000a			isTabIndexNotNaN) &&\u000a		// the element and all of its ancestors must be visible\u000a		visible( element );\u000a}\u000a\u000afunction visible( element ) {\u000a	return $.expr.filters.visible( element ) &&\u000a		!$( element ).parents().andSelf().filter(function() {\u000a			return $.css( this, "visibility" ) === "hidden";\u000a		}).length;\u000a}\u000a\u000a$.extend( $.expr[ ":" ], {\u000a	data: $.expr.createPseudo ?\u000a		$.expr.createPseudo(function( dataName ) {\u000a			return function( elem ) {\u000a				return !!$.data( elem, dataName );\u000a			};\u000a		}) :\u000a		// support: jQuery <1.8\u000a		function( elem, i, match ) {\u000a			return !!$.data( elem, match[ 3 ] );\u000a		},\u000a\u000a	focusable: function( element ) {\u000a		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );\u000a	},\u000a\u000a	tabbable: function( element ) {\u000a		var tabIndex = $.attr( element, "tabindex" ),\u000a			isTabIndexNaN = isNaN( tabIndex );\u000a		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\u000a	}\u000a});\u000a\u000a// support\u000a$(function() {\u000a	var body = document.body,\u000a		div = body.appendChild( div = document.createElement( "div" ) );\u000a\u000a	// access offsetHeight before setting the style to prevent a layout bug\u000a	// in IE 9 which causes the element to continue to take up space even\u000a	// after it is removed from the DOM (#8026)\u000a	div.offsetHeight;\u000a\u000a	$.extend( div.style, {\u000a		minHeight: "100px",\u000a		height: "auto",\u000a		padding: 0,\u000a		borderWidth: 0\u000a	});\u000a\u000a	$.support.minHeight = div.offsetHeight === 100;\u000a	$.support.selectstart = "onselectstart" in div;\u000a\u000a	// set display to none to avoid a layout bug in IE\u000a	// http://dev.jquery.com/ticket/4014\u000a	body.removeChild( div ).style.display = "none";\u000a});\u000a\u000a// support: jQuery <1.8\u000aif ( !$( "<a>" ).outerWidth( 1 ).jquery ) {\u000a	$.each( [ "Width", "Height" ], function( i, name ) {\u000a		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],\u000a			type = name.toLowerCase(),\u000a			orig = {\u000a				innerWidth: $.fn.innerWidth,\u000a				innerHeight: $.fn.innerHeight,\u000a				outerWidth: $.fn.outerWidth,\u000a				outerHeight: $.fn.outerHeight\u000a			};\u000a\u000a		function reduce( elem, size, border, margin ) {\u000a			$.each( side, function() {\u000a				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;\u000a				if ( border ) {\u000a					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;\u000a				}\u000a				if ( margin ) {\u000a					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;\u000a				}\u000a			});\u000a			return size;\u000a		}\u000a\u000a		$.fn[ "inner" + name ] = function( size ) {\u000a			if ( size === undefined ) {\u000a				return orig[ "inner" + name ].call( this );\u000a			}\u000a\u000a			return this.each(function() {\u000a				$( this ).css( type, reduce( this, size ) + "px" );\u000a			});\u000a		};\u000a\u000a		$.fn[ "outer" + name] = function( size, margin ) {\u000a			if ( typeof size !== "number" ) {\u000a				return orig[ "outer" + name ].call( this, size );\u000a			}\u000a\u000a			return this.each(function() {\u000a				$( this).css( type, reduce( this, size, true, margin ) + "px" );\u000a			});\u000a		};\u000a	});\u000a}\u000a\u000a// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\u000aif ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {\u000a	$.fn.removeData = (function( removeData ) {\u000a		return function( key ) {\u000a			if ( arguments.length ) {\u000a				return removeData.call( this, $.camelCase( key ) );\u000a			} else {\u000a				return removeData.call( this );\u000a			}\u000a		};\u000a	})( $.fn.removeData );\u000a}\u000a\u000a\u000a\u000a\u000a\u000a// deprecated\u000a\u000a(function() {\u000a	var uaMatch = /msie ([\u005cw.]+)/.exec( navigator.userAgent.toLowerCase() ) || [];\u000a	$.ui.ie = uaMatch.length ? true : false;\u000a	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;\u000a})();\u000a\u000a$.fn.extend({\u000a	disableSelection: function() {\u000a		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +\u000a			".ui-disableSelection", function( event ) {\u000a				event.preventDefault();\u000a			});\u000a	},\u000a\u000a	enableSelection: function() {\u000a		return this.unbind( ".ui-disableSelection" );\u000a	}\u000a});\u000a\u000a$.extend( $.ui, {\u000a	// $.ui.plugin is deprecated.  Use the proxy pattern instead.\u000a	plugin: {\u000a		add: function( module, option, set ) {\u000a			var i,\u000a				proto = $.ui[ module ].prototype;\u000a			for ( i in set ) {\u000a				proto.plugins[ i ] = proto.plugins[ i ] || [];\u000a				proto.plugins[ i ].push( [ option, set[ i ] ] );\u000a			}\u000a		},\u000a		call: function( instance, name, args ) {\u000a			var i,\u000a				set = instance.plugins[ name ];\u000a			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\u000a				return;\u000a			}\u000a\u000a			for ( i = 0; i < set.length; i++ ) {\u000a				if ( instance.options[ set[ i ][ 0 ] ] ) {\u000a					set[ i ][ 1 ].apply( instance.element, args );\u000a				}\u000a			}\u000a		}\u000a	},\u000a\u000a	contains: $.contains,\u000a\u000a	// only used by resizable\u000a	hasScroll: function( el, a ) {\u000a\u000a		//If overflow is hidden, the element might have extra content, but the user wants to hide it\u000a		if ( $( el ).css( "overflow" ) === "hidden") {\u000a			return false;\u000a		}\u000a\u000a		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",\u000a			has = false;\u000a\u000a		if ( el[ scroll ] > 0 ) {\u000a			return true;\u000a		}\u000a\u000a		// TODO: determine which cases actually cause this to happen\u000a		// if the element doesn't have the scroll set, see if it's possible to\u000a		// set the scroll\u000a		el[ scroll ] = 1;\u000a		has = ( el[ scroll ] > 0 );\u000a		el[ scroll ] = 0;\u000a		return has;\u000a	},\u000a\u000a	// these are odd functions, fix the API or move into individual plugins\u000a	isOverAxis: function( x, reference, size ) {\u000a		//Determines when x coordinate is over "b" element axis\u000a		return ( x > reference ) && ( x < ( reference + size ) );\u000a	},\u000a	isOver: function( y, x, top, left, height, width ) {\u000a		//Determines when x, y coordinates is over "b" element\u000a		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );\u000a	}\u000a});\u000a\u000a})( jQuery );\u000a(function( $, undefined ) {\u000a\u000avar uuid = 0,\u000a	slice = Array.prototype.slice,\u000a	_cleanData = $.cleanData;\u000a$.cleanData = function( elems ) {\u000a	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\u000a		try {\u000a			$( elem ).triggerHandler( "remove" );\u000a		// http://bugs.jquery.com/ticket/8235\u000a		} catch( e ) {}\u000a	}\u000a	_cleanData( elems );\u000a};\u000a\u000a$.widget = function( name, base, prototype ) {\u000a	var fullName, existingConstructor, constructor, basePrototype,\u000a		namespace = name.split( "." )[ 0 ];\u000a\u000a	name = name.split( "." )[ 1 ];\u000a	fullName = namespace + "-" + name;\u000a\u000a	if ( !prototype ) {\u000a		prototype = base;\u000a		base = $.Widget;\u000a	}\u000a\u000a	// create selector for plugin\u000a	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\u000a		return !!$.data( elem, fullName );\u000a	};\u000a\u000a	$[ namespace ] = $[ namespace ] || {};\u000a	existingConstructor = $[ namespace ][ name ];\u000a	constructor = $[ namespace ][ name ] = function( options, element ) {\u000a		// allow instantiation without "new" keyword\u000a		if ( !this._createWidget ) {\u000a			return new constructor( options, element );\u000a		}\u000a\u000a		// allow instantiation without initializing for simple inheritance\u000a		// must use "new" keyword (the code above always passes args)\u000a		if ( arguments.length ) {\u000a			this._createWidget( options, element );\u000a		}\u000a	};\u000a	// extend with the existing constructor to carry over any static properties\u000a	$.extend( constructor, existingConstructor, {\u000a		version: prototype.version,\u000a		// copy the object used to create the prototype in case we need to\u000a		// redefine the widget later\u000a		_proto: $.extend( {}, prototype ),\u000a		// track widgets that inherit from this widget in case this widget is\u000a		// redefined after a widget inherits from it\u000a		_childConstructors: []\u000a	});\u000a\u000a	basePrototype = new base();\u000a	// we need to make the options hash a property directly on the new instance\u000a	// otherwise we'll modify the options hash on the prototype that we're\u000a	// inheriting from\u000a	basePrototype.options = $.widget.extend( {}, basePrototype.options );\u000a	$.each( prototype, function( prop, value ) {\u000a		if ( $.isFunction( value ) ) {\u000a			prototype[ prop ] = (function() {\u000a				var _super = function() {\u000a						return base.prototype[ prop ].apply( this, arguments );\u000a					},\u000a					_superApply = function( args ) {\u000a						return base.prototype[ prop ].apply( this, args );\u000a					};\u000a				return function() {\u000a					var __super = this._super,\u000a						__superApply = this._superApply,\u000a						returnValue;\u000a\u000a					this._super = _super;\u000a					this._superApply = _superApply;\u000a\u000a					returnValue = value.apply( this, arguments );\u000a\u000a					this._super = __super;\u000a					this._superApply = __superApply;\u000a\u000a					return returnValue;\u000a				};\u000a			})();\u000a		}\u000a	});\u000a	constructor.prototype = $.widget.extend( basePrototype, {\u000a		// TODO: remove support for widgetEventPrefix\u000a		// always use the name + a colon as the prefix, e.g., draggable:start\u000a		// don't prefix for widgets that aren't DOM-based\u000a		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name\u000a	}, prototype, {\u000a		constructor: constructor,\u000a		namespace: namespace,\u000a		widgetName: name,\u000a		// TODO remove widgetBaseClass, see #8155\u000a		widgetBaseClass: fullName,\u000a		widgetFullName: fullName\u000a	});\u000a\u000a	// If this widget is being redefined then we need to find all widgets that\u000a	// are inheriting from it and redefine all of them so that they inherit from\u000a	// the new version of this widget. We're essentially trying to replace one\u000a	// level in the prototype chain.\u000a	if ( existingConstructor ) {\u000a		$.each( existingConstructor._childConstructors, function( i, child ) {\u000a			var childPrototype = child.prototype;\u000a\u000a			// redefine the child widget using the same prototype that was\u000a			// originally used, but inherit from the new version of the base\u000a			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );\u000a		});\u000a		// remove the list of existing child constructors from the old constructor\u000a		// so the old child constructors can be garbage collected\u000a		delete existingConstructor._childConstructors;\u000a	} else {\u000a		base._childConstructors.push( constructor );\u000a	}\u000a\u000a	$.widget.bridge( name, constructor );\u000a};\u000a\u000a$.widget.extend = function( target ) {\u000a	var input = slice.call( arguments, 1 ),\u000a		inputIndex = 0,\u000a		inputLength = input.length,\u000a		key,\u000a		value;\u000a	for ( ; inputIndex < inputLength; inputIndex++ ) {\u000a		for ( key in input[ inputIndex ] ) {\u000a			value = input[ inputIndex ][ key ];\u000a			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\u000a				// Clone objects\u000a				if ( $.isPlainObject( value ) ) {\u000a					target[ key ] = $.isPlainObject( target[ key ] ) ?\u000a						$.widget.extend( {}, target[ key ], value ) :\u000a						// Don't extend strings, arrays, etc. with objects\u000a						$.widget.extend( {}, value );\u000a				// Copy everything else by reference\u000a				} else {\u000a					target[ key ] = value;\u000a				}\u000a			}\u000a		}\u000a	}\u000a	return target;\u000a};\u000a\u000a$.widget.bridge = function( name, object ) {\u000a	var fullName = object.prototype.widgetFullName || name;\u000a	$.fn[ name ] = function( options ) {\u000a		var isMethodCall = typeof options === "string",\u000a			args = slice.call( arguments, 1 ),\u000a			returnValue = this;\u000a\u000a		// allow multiple hashes to be passed on init\u000a		options = !isMethodCall && args.length ?\u000a			$.widget.extend.apply( null, [ options ].concat(args) ) :\u000a			options;\u000a\u000a		if ( isMethodCall ) {\u000a			this.each(function() {\u000a				var methodValue,\u000a					instance = $.data( this, fullName );\u000a				if ( !instance ) {\u000a					return $.error( "cannot call methods on " + name + " prior to initialization; " +\u000a						"attempted to call method '" + options + "'" );\u000a				}\u000a				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {\u000a					return $.error( "no such method '" + options + "' for " + name + " widget instance" );\u000a				}\u000a				methodValue = instance[ options ].apply( instance, args );\u000a				if ( methodValue !== instance && methodValue !== undefined ) {\u000a					returnValue = methodValue && methodValue.jquery ?\u000a						returnValue.pushStack( methodValue.get() ) :\u000a						methodValue;\u000a					return false;\u000a				}\u000a			});\u000a		} else {\u000a			this.each(function() {\u000a				var instance = $.data( this, fullName );\u000a				if ( instance ) {\u000a					instance.option( options || {} )._init();\u000a				} else {\u000a					$.data( this, fullName, new object( options, this ) );\u000a				}\u000a			});\u000a		}\u000a\u000a		return returnValue;\u000a	};\u000a};\u000a\u000a$.Widget = function( /* options, element */ ) {};\u000a$.Widget._childConstructors = [];\u000a\u000a$.Widget.prototype = {\u000a	widgetName: "widget",\u000a	widgetEventPrefix: "",\u000a	defaultElement: "<div>",\u000a	options: {\u000a		disabled: false,\u000a\u000a		// callbacks\u000a		create: null\u000a	},\u000a	_createWidget: function( options, element ) {\u000a		element = $( element || this.defaultElement || this )[ 0 ];\u000a		this.element = $( element );\u000a		this.uuid = uuid++;\u000a		this.eventNamespace = "." + this.widgetName + this.uuid;\u000a		this.options = $.widget.extend( {},\u000a			this.options,\u000a			this._getCreateOptions(),\u000a			options );\u000a\u000a		this.bindings = $();\u000a		this.hoverable = $();\u000a		this.focusable = $();\u000a\u000a		if ( element !== this ) {\u000a			// 1.9 BC for #7810\u000a			// TODO remove dual storage\u000a			$.data( element, this.widgetName, this );\u000a			$.data( element, this.widgetFullName, this );\u000a			this._on( true, this.element, {\u000a				remove: function( event ) {\u000a					if ( event.target === element ) {\u000a						this.destroy();\u000a					}\u000a				}\u000a			});\u000a			this.document = $( element.style ?\u000a				// element within the document\u000a				element.ownerDocument :\u000a				// element is window or document\u000a				element.document || element );\u000a			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\u000a		}\u000a\u000a		this._create();\u000a		this._trigger( "create", null, this._getCreateEventData() );\u000a		this._init();\u000a	},\u000a	_getCreateOptions: $.noop,\u000a	_getCreateEventData: $.noop,\u000a	_create: $.noop,\u000a	_init: $.noop,\u000a\u000a	destroy: function() {\u000a		this._destroy();\u000a		// we can probably remove the unbind calls in 2.0\u000a		// all event bindings should go through this._on()\u000a		this.element\u000a			.unbind( this.eventNamespace )\u000a			// 1.9 BC for #7810\u000a			// TODO remove dual storage\u000a			.removeData( this.widgetName )\u000a			.removeData( this.widgetFullName )\u000a			// support: jquery <1.6.3\u000a			// http://bugs.jquery.com/ticket/9413\u000a			.removeData( $.camelCase( this.widgetFullName ) );\u000a		this.widget()\u000a			.unbind( this.eventNamespace )\u000a			.removeAttr( "aria-disabled" )\u000a			.removeClass(\u000a				this.widgetFullName + "-disabled " +\u000a				"ui-state-disabled" );\u000a\u000a		// clean up events and states\u000a		this.bindings.unbind( this.eventNamespace );\u000a		this.hoverable.removeClass( "ui-state-hover" );\u000a		this.focusable.removeClass( "ui-state-focus" );\u000a	},\u000a	_destroy: $.noop,\u000a\u000a	widget: function() {\u000a		return this.element;\u000a	},\u000a\u000a	option: function( key, value ) {\u000a		var options = key,\u000a			parts,\u000a			curOption,\u000a			i;\u000a\u000a		if ( arguments.length === 0 ) {\u000a			// don't return a reference to the internal hash\u000a			return $.widget.extend( {}, this.options );\u000a		}\u000a\u000a		if ( typeof key === "string" ) {\u000a			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\u000a			options = {};\u000a			parts = key.split( "." );\u000a			key = parts.shift();\u000a			if ( parts.length ) {\u000a				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\u000a				for ( i = 0; i < parts.length - 1; i++ ) {\u000a					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\u000a					curOption = curOption[ parts[ i ] ];\u000a				}\u000a				key = parts.pop();\u000a				if ( value === undefined ) {\u000a					return curOption[ key ] === undefined ? null : curOption[ key ];\u000a				}\u000a				curOption[ key ] = value;\u000a			} else {\u000a				if ( value === undefined ) {\u000a					return this.options[ key ] === undefined ? null : this.options[ key ];\u000a				}\u000a				options[ key ] = value;\u000a			}\u000a		}\u000a\u000a		this._setOptions( options );\u000a\u000a		return this;\u000a	},\u000a	_setOptions: function( options ) {\u000a		var key;\u000a\u000a		for ( key in options ) {\u000a			this._setOption( key, options[ key ] );\u000a		}\u000a\u000a		return this;\u000a	},\u000a	_setOption: function( key, value ) {\u000a		this.options[ key ] = value;\u000a\u000a		if ( key === "disabled" ) {\u000a			this.widget()\u000a				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )\u000a				.attr( "aria-disabled", value );\u000a			this.hoverable.removeClass( "ui-state-hover" );\u000a			this.focusable.removeClass( "ui-state-focus" );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	enable: function() {\u000a		return this._setOption( "disabled", false );\u000a	},\u000a	disable: function() {\u000a		return this._setOption( "disabled", true );\u000a	},\u000a\u000a	_on: function( suppressDisabledCheck, element, handlers ) {\u000a		var delegateElement,\u000a			instance = this;\u000a\u000a		// no suppressDisabledCheck flag, shuffle arguments\u000a		if ( typeof suppressDisabledCheck !== "boolean" ) {\u000a			handlers = element;\u000a			element = suppressDisabledCheck;\u000a			suppressDisabledCheck = false;\u000a		}\u000a\u000a		// no element argument, shuffle and use this.element\u000a		if ( !handlers ) {\u000a			handlers = element;\u000a			element = this.element;\u000a			delegateElement = this.widget();\u000a		} else {\u000a			// accept selectors, DOM elements\u000a			element = delegateElement = $( element );\u000a			this.bindings = this.bindings.add( element );\u000a		}\u000a\u000a		$.each( handlers, function( event, handler ) {\u000a			function handlerProxy() {\u000a				// allow widgets to customize the disabled handling\u000a				// - disabled as an array instead of boolean\u000a				// - disabled class as method for disabling individual parts\u000a				if ( !suppressDisabledCheck &&\u000a						( instance.options.disabled === true ||\u000a							$( this ).hasClass( "ui-state-disabled" ) ) ) {\u000a					return;\u000a				}\u000a				return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a					.apply( instance, arguments );\u000a			}\u000a\u000a			// copy the guid so direct unbinding works\u000a			if ( typeof handler !== "string" ) {\u000a				handlerProxy.guid = handler.guid =\u000a					handler.guid || handlerProxy.guid || $.guid++;\u000a			}\u000a\u000a			var match = event.match( /^(\u005cw+)\u005cs*(.*)$/ ),\u000a				eventName = match[1] + instance.eventNamespace,\u000a				selector = match[2];\u000a			if ( selector ) {\u000a				delegateElement.delegate( selector, eventName, handlerProxy );\u000a			} else {\u000a				element.bind( eventName, handlerProxy );\u000a			}\u000a		});\u000a	},\u000a\u000a	_off: function( element, eventName ) {\u000a		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;\u000a		element.unbind( eventName ).undelegate( eventName );\u000a	},\u000a\u000a	_delay: function( handler, delay ) {\u000a		function handlerProxy() {\u000a			return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a				.apply( instance, arguments );\u000a		}\u000a		var instance = this;\u000a		return setTimeout( handlerProxy, delay || 0 );\u000a	},\u000a\u000a	_hoverable: function( element ) {\u000a		this.hoverable = this.hoverable.add( element );\u000a		this._on( element, {\u000a			mouseenter: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-hover" );\u000a			},\u000a			mouseleave: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-hover" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_focusable: function( element ) {\u000a		this.focusable = this.focusable.add( element );\u000a		this._on( element, {\u000a			focusin: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-focus" );\u000a			},\u000a			focusout: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-focus" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_trigger: function( type, event, data ) {\u000a		var prop, orig,\u000a			callback = this.options[ type ];\u000a\u000a		data = data || {};\u000a		event = $.Event( event );\u000a		event.type = ( type === this.widgetEventPrefix ?\u000a			type :\u000a			this.widgetEventPrefix + type ).toLowerCase();\u000a		// the original event may come from any element\u000a		// so we need to reset the target on the new event\u000a		event.target = this.element[ 0 ];\u000a\u000a		// copy original event properties over to the new event\u000a		orig = event.originalEvent;\u000a		if ( orig ) {\u000a			for ( prop in orig ) {\u000a				if ( !( prop in event ) ) {\u000a					event[ prop ] = orig[ prop ];\u000a				}\u000a			}\u000a		}\u000a\u000a		this.element.trigger( event, data );\u000a		return !( $.isFunction( callback ) &&\u000a			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\u000a			event.isDefaultPrevented() );\u000a	}\u000a};\u000a\u000a$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\u000a	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\u000a		if ( typeof options === "string" ) {\u000a			options = { effect: options };\u000a		}\u000a		var hasOptions,\u000a			effectName = !options ?\u000a				method :\u000a				options === true || typeof options === "number" ?\u000a					defaultEffect :\u000a					options.effect || defaultEffect;\u000a		options = options || {};\u000a		if ( typeof options === "number" ) {\u000a			options = { duration: options };\u000a		}\u000a		hasOptions = !$.isEmptyObject( options );\u000a		options.complete = callback;\u000a		if ( options.delay ) {\u000a			element.delay( options.delay );\u000a		}\u000a		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {\u000a			element[ method ]( options );\u000a		} else if ( effectName !== method && element[ effectName ] ) {\u000a			element[ effectName ]( options.duration, options.easing, callback );\u000a		} else {\u000a			element.queue(function( next ) {\u000a				$( this )[ method ]();\u000a				if ( callback ) {\u000a					callback.call( element[ 0 ] );\u000a				}\u000a				next();\u000a			});\u000a		}\u000a	};\u000a});\u000a\u000a// DEPRECATED\u000aif ( $.uiBackCompat !== false ) {\u000a	$.Widget.prototype._getCreateOptions = function() {\u000a		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];\u000a	};\u000a}\u000a\u000a})( jQuery );\u000a(function( $, undefined ) {\u000a\u000avar mouseHandled = false;\u000a$( document ).mouseup( function( e ) {\u000a	mouseHandled = false;\u000a});\u000a\u000a$.widget("ui.mouse", {\u000a	version: "1.9.2",\u000a	options: {\u000a		cancel: 'input,textarea,button,select,option',\u000a		distance: 1,\u000a		delay: 0\u000a	},\u000a	_mouseInit: function() {\u000a		var that = this;\u000a\u000a		this.element\u000a			.bind('mousedown.'+this.widgetName, function(event) {\u000a				return that._mouseDown(event);\u000a			})\u000a			.bind('click.'+this.widgetName, function(event) {\u000a				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {\u000a					$.removeData(event.target, that.widgetName + '.preventClickEvent');\u000a					event.stopImmediatePropagation();\u000a					return false;\u000a				}\u000a			});\u000a\u000a		this.started = false;\u000a	},\u000a\u000a	// TODO: make sure destroying one instance of mouse doesn't mess with\u000a	// other instances of mouse\u000a	_mouseDestroy: function() {\u000a		this.element.unbind('.'+this.widgetName);\u000a		if ( this._mouseMoveDelegate ) {\u000a			$(document)\u000a				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a		}\u000a	},\u000a\u000a	_mouseDown: function(event) {\u000a		// don't let more than one widget handle mouseStart\u000a		if( mouseHandled ) { return; }\u000a\u000a		// we may have missed mouseup (out of window)\u000a		(this._mouseStarted && this._mouseUp(event));\u000a\u000a		this._mouseDownEvent = event;\u000a\u000a		var that = this,\u000a			btnIsLeft = (event.which === 1),\u000a			// event.target.nodeName works around a bug in IE 8 with\u000a			// disabled inputs (#7620)\u000a			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\u000a		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\u000a			return true;\u000a		}\u000a\u000a		this.mouseDelayMet = !this.options.delay;\u000a		if (!this.mouseDelayMet) {\u000a			this._mouseDelayTimer = setTimeout(function() {\u000a				that.mouseDelayMet = true;\u000a			}, this.options.delay);\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted = (this._mouseStart(event) !== false);\u000a			if (!this._mouseStarted) {\u000a				event.preventDefault();\u000a				return true;\u000a			}\u000a		}\u000a\u000a		// Click event may never have fired (Gecko & Opera)\u000a		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {\u000a			$.removeData(event.target, this.widgetName + '.preventClickEvent');\u000a		}\u000a\u000a		// these delegates are required to keep context\u000a		this._mouseMoveDelegate = function(event) {\u000a			return that._mouseMove(event);\u000a		};\u000a		this._mouseUpDelegate = function(event) {\u000a			return that._mouseUp(event);\u000a		};\u000a		$(document)\u000a			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a\u000a		event.preventDefault();\u000a\u000a		mouseHandled = true;\u000a		return true;\u000a	},\u000a\u000a	_mouseMove: function(event) {\u000a		// IE mouseup check - mouseup happened when mouse was out of window\u000a		if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {\u000a			return this._mouseUp(event);\u000a		}\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseDrag(event);\u000a			return event.preventDefault();\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted =\u000a				(this._mouseStart(this._mouseDownEvent, event) !== false);\u000a			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\u000a		}\u000a\u000a		return !this._mouseStarted;\u000a	},\u000a\u000a	_mouseUp: function(event) {\u000a		$(document)\u000a			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseStarted = false;\u000a\u000a			if (event.target === this._mouseDownEvent.target) {\u000a				$.data(event.target, this.widgetName + '.preventClickEvent', true);\u000a			}\u000a\u000a			this._mouseStop(event);\u000a		}\u000a\u000a		return false;\u000a	},\u000a\u000a	_mouseDistanceMet: function(event) {\u000a		return (Math.max(\u000a				Math.abs(this._mouseDownEvent.pageX - event.pageX),\u000a				Math.abs(this._mouseDownEvent.pageY - event.pageY)\u000a			) >= this.options.distance\u000a		);\u000a	},\u000a\u000a	_mouseDelayMet: function(event) {\u000a		return this.mouseDelayMet;\u000a	},\u000a\u000a	// These are placeholder methods, to be overriden by extending plugin\u000a	_mouseStart: function(event) {},\u000a	_mouseDrag: function(event) {},\u000a	_mouseStop: function(event) {},\u000a	_mouseCapture: function(event) { return true; }\u000a});\u000a\u000a})(jQuery);\u000a(function( $, undefined ) {\u000a\u000a$.widget("ui.sortable", $.ui.mouse, {\u000a	version: "1.9.2",\u000a	widgetEventPrefix: "sort",\u000a	ready: false,\u000a	options: {\u000a		appendTo: "parent",\u000a		axis: false,\u000a		connectWith: false,\u000a		containment: false,\u000a		cursor: 'auto',\u000a		cursorAt: false,\u000a		dropOnEmpty: true,\u000a		forcePlaceholderSize: false,\u000a		forceHelperSize: false,\u000a		grid: false,\u000a		handle: false,\u000a		helper: "original",\u000a		items: '> *',\u000a		opacity: false,\u000a		placeholder: false,\u000a		revert: false,\u000a		scroll: true,\u000a		scrollSensitivity: 20,\u000a		scrollSpeed: 20,\u000a		scope: "default",\u000a		tolerance: "intersect",\u000a		zIndex: 1000\u000a	},\u000a	_create: function() {\u000a\u000a		var o = this.options;\u000a		this.containerCache = {};\u000a		this.element.addClass("ui-sortable");\u000a\u000a		//Get the items\u000a		this.refresh();\u000a\u000a		//Let's determine if the items are being displayed horizontally\u000a		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;\u000a\u000a		//Let's determine the parent's offset\u000a		this.offset = this.element.offset();\u000a\u000a		//Initialize mouse events for interaction\u000a		this._mouseInit();\u000a\u000a		//We're ready to go\u000a		this.ready = true\u000a\u000a	},\u000a\u000a	_destroy: function() {\u000a		this.element\u000a			.removeClass("ui-sortable ui-sortable-disabled");\u000a		this._mouseDestroy();\u000a\u000a		for ( var i = this.items.length - 1; i >= 0; i-- )\u000a			this.items[i].item.removeData(this.widgetName + "-item");\u000a\u000a		return this;\u000a	},\u000a\u000a	_setOption: function(key, value){\u000a		if ( key === "disabled" ) {\u000a			this.options[ key ] = value;\u000a\u000a			this.widget().toggleClass( "ui-sortable-disabled", !!value );\u000a		} else {\u000a			// Don't call widget base _setOption for disable as it adds ui-state-disabled class\u000a			$.Widget.prototype._setOption.apply(this, arguments);\u000a		}\u000a	},\u000a\u000a	_mouseCapture: function(event, overrideHandle) {\u000a		var that = this;\u000a\u000a		if (this.reverting) {\u000a			return false;\u000a		}\u000a\u000a		if(this.options.disabled || this.options.type == 'static') return false;\u000a\u000a		//We have to refresh the items data once first\u000a		this._refreshItems(event);\u000a\u000a		//Find out if the clicked node (or one of its parents) is a actual item in this.items\u000a		var currentItem = null, nodes = $(event.target).parents().each(function() {\u000a			if($.data(this, that.widgetName + '-item') == that) {\u000a				currentItem = $(this);\u000a				return false;\u000a			}\u000a		});\u000a		if($.data(event.target, that.widgetName + '-item') == that) currentItem = $(event.target);\u000a\u000a		if(!currentItem) return false;\u000a		if(this.options.handle && !overrideHandle) {\u000a			var validHandle = false;\u000a\u000a			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });\u000a			if(!validHandle) return false;\u000a		}\u000a\u000a		this.currentItem = currentItem;\u000a		this._removeCurrentsFromItems();\u000a		return true;\u000a\u000a	},\u000a\u000a	_mouseStart: function(event, overrideHandle, noActivation) {\u000a\u000a		var o = this.options;\u000a		this.currentContainer = this;\u000a\u000a		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\u000a		this.refreshPositions();\u000a\u000a		//Create and append the visible helper\u000a		this.helper = this._createHelper(event);\u000a\u000a		//Cache the helper size\u000a		this._cacheHelperProportions();\u000a\u000a		/*\u000a		 * - Position generation -\u000a		 * This block generates everything position related - it's the core of draggables.\u000a		 */\u000a\u000a		//Cache the margins of the original element\u000a		this._cacheMargins();\u000a\u000a		//Get the next scrolling parent\u000a		this.scrollParent = this.helper.scrollParent();\u000a\u000a		//The element's absolute position on the page minus margins\u000a		this.offset = this.currentItem.offset();\u000a		this.offset = {\u000a			top: this.offset.top - this.margins.top,\u000a			left: this.offset.left - this.margins.left\u000a		};\u000a\u000a		$.extend(this.offset, {\u000a			click: { //Where the click happened, relative to the element\u000a				left: event.pageX - this.offset.left,\u000a				top: event.pageY - this.offset.top\u000a			},\u000a			parent: this._getParentOffset(),\u000a			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\u000a		});\u000a\u000a		// Only after we got the offset, we can change the helper's position to absolute\u000a		// TODO: Still need to figure out a way to make relative sorting possible\u000a		this.helper.css("position", "absolute");\u000a		this.cssPosition = this.helper.css("position");\u000a\u000a		//Generate the original position\u000a		this.originalPosition = this._generatePosition(event);\u000a		this.originalPageX = event.pageX;\u000a		this.originalPageY = event.pageY;\u000a\u000a		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied\u000a		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\u000a\u000a		//Cache the former DOM position\u000a		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\u000a\u000a		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\u000a		if(this.helper[0] != this.currentItem[0]) {\u000a			this.currentItem.hide();\u000a		}\u000a\u000a		//Create the placeholder\u000a		this._createPlaceholder();\u000a\u000a		//Set a containment if given in the options\u000a		if(o.containment)\u000a			this._setContainment();\u000a\u000a		if(o.cursor) { // cursor option\u000a			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");\u000a			$('body').css("cursor", o.cursor);\u000a		}\u000a\u000a		if(o.opacity) { // opacity option\u000a			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");\u000a			this.helper.css("opacity", o.opacity);\u000a		}\u000a\u000a		if(o.zIndex) { // zIndex option\u000a			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");\u000a			this.helper.css("zIndex", o.zIndex);\u000a		}\u000a\u000a		//Prepare scrolling\u000a		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')\u000a			this.overflowOffset = this.scrollParent.offset();\u000a\u000a		//Call callbacks\u000a		this._trigger("start", event, this._uiHash());\u000a\u000a		//Recache the helper size\u000a		if(!this._preserveHelperProportions)\u000a			this._cacheHelperProportions();\u000a\u000a\u000a		//Post 'activate' events to possible containers\u000a		if(!noActivation) {\u000a			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, this._uiHash(this)); }\u000a		}\u000a\u000a		//Prepare possible droppables\u000a		if($.ui.ddmanager)\u000a			$.ui.ddmanager.current = this;\u000a\u000a		if ($.ui.ddmanager && !o.dropBehaviour)\u000a			$.ui.ddmanager.prepareOffsets(this, event);\u000a\u000a		this.dragging = true;\u000a\u000a		this.helper.addClass("ui-sortable-helper");\u000a		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\u000a		return true;\u000a\u000a	},\u000a\u000a	_mouseDrag: function(event) {\u000a\u000a		//Compute the helpers position\u000a		this.position = this._generatePosition(event);\u000a		this.positionAbs = this._convertPositionTo("absolute");\u000a\u000a		if (!this.lastPositionAbs) {\u000a			this.lastPositionAbs = this.positionAbs;\u000a		}\u000a\u000a		//Do scrolling\u000a		if(this.options.scroll) {\u000a			var o = this.options, scrolled = false;\u000a			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {\u000a\u000a				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)\u000a					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\u000a				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)\u000a					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\u000a\u000a				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)\u000a					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\u000a				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)\u000a					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\u000a\u000a			} else {\u000a\u000a				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)\u000a					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\u000a				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)\u000a					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\u000a\u000a				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)\u000a					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\u000a				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)\u000a					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\u000a\u000a			}\u000a\u000a			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)\u000a				$.ui.ddmanager.prepareOffsets(this, event);\u000a		}\u000a\u000a		//Regenerate the absolute position used for position checks\u000a		this.positionAbs = this._convertPositionTo("absolute");\u000a\u000a		//Set the helper position\u000a		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';\u000a		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';\u000a\u000a		//Rearrange\u000a		for (var i = this.items.length - 1; i >= 0; i--) {\u000a\u000a			//Cache variables and intersection, continue if no intersection\u000a			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);\u000a			if (!intersection) continue;\u000a\u000a			// Only put the placeholder inside the current Container, skip all\u000a			// items form other containers. This works because when moving\u000a			// an item from one container to another the\u000a			// currentContainer is switched before the placeholder is moved.\u000a			//\u000a			// Without this moving items in "sub-sortables" can cause the placeholder to jitter\u000a			// beetween the outer and inner container.\u000a			if (item.instance !== this.currentContainer) continue;\u000a\u000a			if (itemElement != this.currentItem[0] //cannot intersect with itself\u000a				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before\u000a				&&	!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked\u000a				&& (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)\u000a				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container\u000a			) {\u000a\u000a				this.direction = intersection == 1 ? "down" : "up";\u000a\u000a				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {\u000a					this._rearrange(event, item);\u000a				} else {\u000a					break;\u000a				}\u000a\u000a				this._trigger("change", event, this._uiHash());\u000a				break;\u000a			}\u000a		}\u000a\u000a		//Post events to containers\u000a		this._contactContainers(event);\u000a\u000a		//Interconnect with droppables\u000a		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);\u000a\u000a		//Call callbacks\u000a		this._trigger('sort', event, this._uiHash());\u000a\u000a		this.lastPositionAbs = this.positionAbs;\u000a		return false;\u000a\u000a	},\u000a\u000a	_mouseStop: function(event, noPropagation) {\u000a\u000a		if(!event) return;\u000a\u000a		//If we are using droppables, inform the manager about the drop\u000a		if ($.ui.ddmanager && !this.options.dropBehaviour)\u000a			$.ui.ddmanager.drop(this, event);\u000a\u000a		if(this.options.revert) {\u000a			var that = this;\u000a			var cur = this.placeholder.offset();\u000a\u000a			this.reverting = true;\u000a\u000a			$(this.helper).animate({\u000a				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),\u000a				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)\u000a			}, parseInt(this.options.revert, 10) || 500, function() {\u000a				that._clear(event);\u000a			});\u000a		} else {\u000a			this._clear(event, noPropagation);\u000a		}\u000a\u000a		return false;\u000a\u000a	},\u000a\u000a	cancel: function() {\u000a\u000a		if(this.dragging) {\u000a\u000a			this._mouseUp({ target: null });\u000a\u000a			if(this.options.helper == "original")\u000a				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\u000a			else\u000a				this.currentItem.show();\u000a\u000a			//Post deactivating events to containers\u000a			for (var i = this.containers.length - 1; i >= 0; i--){\u000a				this.containers[i]._trigger("deactivate", null, this._uiHash(this));\u000a				if(this.containers[i].containerCache.over) {\u000a					this.containers[i]._trigger("out", null, this._uiHash(this));\u000a					this.containers[i].containerCache.over = 0;\u000a				}\u000a			}\u000a\u000a		}\u000a\u000a		if (this.placeholder) {\u000a			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\u000a			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\u000a			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();\u000a\u000a			$.extend(this, {\u000a				helper: null,\u000a				dragging: false,\u000a				reverting: false,\u000a				_noFinalSort: null\u000a			});\u000a\u000a			if(this.domPosition.prev) {\u000a				$(this.domPosition.prev).after(this.currentItem);\u000a			} else {\u000a				$(this.domPosition.parent).prepend(this.currentItem);\u000a			}\u000a		}\u000a\u000a		return this;\u000a\u000a	},\u000a\u000a	serialize: function(o) {\u000a\u000a		var items = this._getItemsAsjQuery(o && o.connected);\u000a		var str = []; o = o || {};\u000a\u000a		$(items).each(function() {\u000a			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));\u000a			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));\u000a		});\u000a\u000a		if(!str.length && o.key) {\u000a			str.push(o.key + '=');\u000a		}\u000a\u000a		return str.join('&');\u000a\u000a	},\u000a\u000a	toArray: function(o) {\u000a\u000a		var items = this._getItemsAsjQuery(o && o.connected);\u000a		var ret = []; o = o || {};\u000a\u000a		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });\u000a		return ret;\u000a\u000a	},\u000a\u000a	/* Be careful with the following core functions */\u000a	_intersectsWith: function(item) {\u000a\u000a		var x1 = this.positionAbs.left,\u000a			x2 = x1 + this.helperProportions.width,\u000a			y1 = this.positionAbs.top,\u000a			y2 = y1 + this.helperProportions.height;\u000a\u000a		var l = item.left,\u000a			r = l + item.width,\u000a			t = item.top,\u000a			b = t + item.height;\u000a\u000a		var dyClick = this.offset.click.top,\u000a			dxClick = this.offset.click.left;\u000a\u000a		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;\u000a\u000a		if(	   this.options.tolerance == "pointer"\u000a			|| this.options.forcePointerForContainers\u000a			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])\u000a		) {\u000a			return isOverElement;\u000a		} else {\u000a\u000a			return (l < x1 + (this.helperProportions.width / 2) // Right Half\u000a				&& x2 - (this.helperProportions.width / 2) < r // Left Half\u000a				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half\u000a				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half\u000a\u000a		}\u000a	},\u000a\u000a	_intersectsWithPointer: function(item) {\u000a\u000a		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\u000a			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\u000a			isOverElement = isOverElementHeight && isOverElementWidth,\u000a			verticalDirection = this._getDragVerticalDirection(),\u000a			horizontalDirection = this._getDragHorizontalDirection();\u000a\u000a		if (!isOverElement)\u000a			return false;\u000a\u000a		return this.floating ?\u000a			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )\u000a			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );\u000a\u000a	},\u000a\u000a	_intersectsWithSides: function(item) {\u000a\u000a		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\u000a			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\u000a			verticalDirection = this._getDragVerticalDirection(),\u000a			horizontalDirection = this._getDragHorizontalDirection();\u000a\u000a		if (this.floating && horizontalDirection) {\u000a			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));\u000a		} else {\u000a			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));\u000a		}\u000a\u000a	},\u000a\u000a	_getDragVerticalDirection: function() {\u000a		var delta = this.positionAbs.top - this.lastPositionAbs.top;\u000a		return delta != 0 && (delta > 0 ? "down" : "up");\u000a	},\u000a\u000a	_getDragHorizontalDirection: function() {\u000a		var delta = this.positionAbs.left - this.lastPositionAbs.left;\u000a		return delta != 0 && (delta > 0 ? "right" : "left");\u000a	},\u000a\u000a	refresh: function(event) {\u000a		this._refreshItems(event);\u000a		this.refreshPositions();\u000a		return this;\u000a	},\u000a\u000a	_connectWith: function() {\u000a		var options = this.options;\u000a		return options.connectWith.constructor == String\u000a			? [options.connectWith]\u000a			: options.connectWith;\u000a	},\u000a\u000a	_getItemsAsjQuery: function(connected) {\u000a\u000a		var items = [];\u000a		var queries = [];\u000a		var connectWith = this._connectWith();\u000a\u000a		if(connectWith && connected) {\u000a			for (var i = connectWith.length - 1; i >= 0; i--){\u000a				var cur = $(connectWith[i]);\u000a				for (var j = cur.length - 1; j >= 0; j--){\u000a					var inst = $.data(cur[j], this.widgetName);\u000a					if(inst && inst != this && !inst.options.disabled) {\u000a						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);\u000a					}\u000a				};\u000a			};\u000a		}\u000a\u000a		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);\u000a\u000a		for (var i = queries.length - 1; i >= 0; i--){\u000a			queries[i][0].each(function() {\u000a				items.push(this);\u000a			});\u000a		};\u000a\u000a		return $(items);\u000a\u000a	},\u000a\u000a	_removeCurrentsFromItems: function() {\u000a\u000a		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");\u000a\u000a		this.items = $.grep(this.items, function (item) {\u000a			for (var j=0; j < list.length; j++) {\u000a				if(list[j] == item.item[0])\u000a					return false;\u000a			};\u000a			return true;\u000a		});\u000a\u000a	},\u000a\u000a	_refreshItems: function(event) {\u000a\u000a		this.items = [];\u000a		this.containers = [this];\u000a		var items = this.items;\u000a		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];\u000a		var connectWith = this._connectWith();\u000a\u000a		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\u000a			for (var i = connectWith.length - 1; i >= 0; i--){\u000a				var cur = $(connectWith[i]);\u000a				for (var j = cur.length - 1; j >= 0; j--){\u000a					var inst = $.data(cur[j], this.widgetName);\u000a					if(inst && inst != this && !inst.options.disabled) {\u000a						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\u000a						this.containers.push(inst);\u000a					}\u000a				};\u000a			};\u000a		}\u000a\u000a		for (var i = queries.length - 1; i >= 0; i--) {\u000a			var targetData = queries[i][1];\u000a			var _queries = queries[i][0];\u000a\u000a			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {\u000a				var item = $(_queries[j]);\u000a\u000a				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)\u000a\u000a				items.push({\u000a					item: item,\u000a					instance: targetData,\u000a					width: 0, height: 0,\u000a					left: 0, top: 0\u000a				});\u000a			};\u000a		};\u000a\u000a	},\u000a\u000a	refreshPositions: function(fast) {\u000a\u000a		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\u000a		if(this.offsetParent && this.helper) {\u000a			this.offset.parent = this._getParentOffset();\u000a		}\u000a\u000a		for (var i = this.items.length - 1; i >= 0; i--){\u000a			var item = this.items[i];\u000a\u000a			//We ignore calculating positions of all connected containers when we're not over them\u000a			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])\u000a				continue;\u000a\u000a			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\u000a\u000a			if (!fast) {\u000a				item.width = t.outerWidth();\u000a				item.height = t.outerHeight();\u000a			}\u000a\u000a			var p = t.offset();\u000a			item.left = p.left;\u000a			item.top = p.top;\u000a		};\u000a\u000a		if(this.options.custom && this.options.custom.refreshContainers) {\u000a			this.options.custom.refreshContainers.call(this);\u000a		} else {\u000a			for (var i = this.containers.length - 1; i >= 0; i--){\u000a				var p = this.containers[i].element.offset();\u000a				this.containers[i].containerCache.left = p.left;\u000a				this.containers[i].containerCache.top = p.top;\u000a				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();\u000a				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\u000a			};\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	_createPlaceholder: function(that) {\u000a		that = that || this;\u000a		var o = that.options;\u000a\u000a		if(!o.placeholder || o.placeholder.constructor == String) {\u000a			var className = o.placeholder;\u000a			o.placeholder = {\u000a				element: function() {\u000a\u000a					var el = $(document.createElement(that.currentItem[0].nodeName))\u000a						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")\u000a						.removeClass("ui-sortable-helper")[0];\u000a\u000a					if(!className)\u000a						el.style.visibility = "hidden";\u000a\u000a					return el;\u000a				},\u000a				update: function(container, p) {\u000a\u000a					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\u000a					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\u000a					if(className && !o.forcePlaceholderSize) return;\u000a\u000a					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\u000a					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop')||0, 10) - parseInt(that.currentItem.css('paddingBottom')||0, 10)); };\u000a					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft')||0, 10) - parseInt(that.currentItem.css('paddingRight')||0, 10)); };\u000a				}\u000a			};\u000a		}\u000a\u000a		//Create the placeholder\u000a		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\u000a\u000a		//Append it after the actual current item\u000a		that.currentItem.after(that.placeholder);\u000a\u000a		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\u000a		o.placeholder.update(that, that.placeholder);\u000a\u000a	},\u000a\u000a	_contactContainers: function(event) {\u000a\u000a		// get innermost container that intersects with item\u000a		var innermostContainer = null, innermostIndex = null;\u000a\u000a\u000a		for (var i = this.containers.length - 1; i >= 0; i--){\u000a\u000a			// never consider a container that's located within the item itself\u000a			if($.contains(this.currentItem[0], this.containers[i].element[0]))\u000a				continue;\u000a\u000a			if(this._intersectsWith(this.containers[i].containerCache)) {\u000a\u000a				// if we've already found a container and it's more "inner" than this, then continue\u000a				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))\u000a					continue;\u000a\u000a				innermostContainer = this.containers[i];\u000a				innermostIndex = i;\u000a\u000a			} else {\u000a				// container doesn't intersect. trigger "out" event if necessary\u000a				if(this.containers[i].containerCache.over) {\u000a					this.containers[i]._trigger("out", event, this._uiHash(this));\u000a					this.containers[i].containerCache.over = 0;\u000a				}\u000a			}\u000a\u000a		}\u000a\u000a		// if no intersecting containers found, return\u000a		if(!innermostContainer) return;\u000a\u000a		// move the item into the container if it's not there already\u000a		if(this.containers.length === 1) {\u000a			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\u000a			this.containers[innermostIndex].containerCache.over = 1;\u000a		} else {\u000a\u000a			//When entering a new container, we will find the item with the least distance and append our item near it\u000a			var dist = 10000; var itemWithLeastDistance = null;\u000a			var posProperty = this.containers[innermostIndex].floating ? 'left' : 'top';\u000a			var sizeProperty = this.containers[innermostIndex].floating ? 'width' : 'height';\u000a			var base = this.positionAbs[posProperty] + this.offset.click[posProperty];\u000a			for (var j = this.items.length - 1; j >= 0; j--) {\u000a				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;\u000a				if(this.items[j].item[0] == this.currentItem[0]) continue;\u000a				var cur = this.items[j].item.offset()[posProperty];\u000a				var nearBottom = false;\u000a				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){\u000a					nearBottom = true;\u000a					cur += this.items[j][sizeProperty];\u000a				}\u000a\u000a				if(Math.abs(cur - base) < dist) {\u000a					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];\u000a					this.direction = nearBottom ? "up": "down";\u000a				}\u000a			}\u000a\u000a			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled\u000a				return;\u000a\u000a			this.currentContainer = this.containers[innermostIndex];\u000a			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\u000a			this._trigger("change", event, this._uiHash());\u000a			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));\u000a\u000a			//Update the placeholder\u000a			this.options.placeholder.update(this.currentContainer, this.placeholder);\u000a\u000a			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\u000a			this.containers[innermostIndex].containerCache.over = 1;\u000a		}\u000a\u000a\u000a	},\u000a\u000a	_createHelper: function(event) {\u000a\u000a		var o = this.options;\u000a		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);\u000a\u000a		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already\u000a			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\u000a\u000a		if(helper[0] == this.currentItem[0])\u000a			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };\u000a\u000a		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());\u000a		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());\u000a\u000a		return helper;\u000a\u000a	},\u000a\u000a	_adjustOffsetFromHelper: function(obj) {\u000a		if (typeof obj == 'string') {\u000a			obj = obj.split(' ');\u000a		}\u000a		if ($.isArray(obj)) {\u000a			obj = {left: +obj[0], top: +obj[1] || 0};\u000a		}\u000a		if ('left' in obj) {\u000a			this.offset.click.left = obj.left + this.margins.left;\u000a		}\u000a		if ('right' in obj) {\u000a			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\u000a		}\u000a		if ('top' in obj) {\u000a			this.offset.click.top = obj.top + this.margins.top;\u000a		}\u000a		if ('bottom' in obj) {\u000a			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\u000a		}\u000a	},\u000a\u000a	_getParentOffset: function() {\u000a\u000a\u000a		//Get the offsetParent and cache its position\u000a		this.offsetParent = this.helper.offsetParent();\u000a		var po = this.offsetParent.offset();\u000a\u000a		// This is a special case where we need to modify a offset calculated on start, since the following happened:\u000a		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\u000a		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\u000a		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\u000a		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\u000a			po.left += this.scrollParent.scrollLeft();\u000a			po.top += this.scrollParent.scrollTop();\u000a		}\u000a\u000a		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information\u000a		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix\u000a			po = { top: 0, left: 0 };\u000a\u000a		return {\u000a			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),\u000a			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)\u000a		};\u000a\u000a	},\u000a\u000a	_getRelativeOffset: function() {\u000a\u000a		if(this.cssPosition == "relative") {\u000a			var p = this.currentItem.position();\u000a			return {\u000a				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),\u000a				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()\u000a			};\u000a		} else {\u000a			return { top: 0, left: 0 };\u000a		}\u000a\u000a	},\u000a\u000a	_cacheMargins: function() {\u000a		this.margins = {\u000a			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),\u000a			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)\u000a		};\u000a	},\u000a\u000a	_cacheHelperProportions: function() {\u000a		this.helperProportions = {\u000a			width: this.helper.outerWidth(),\u000a			height: this.helper.outerHeight()\u000a		};\u000a	},\u000a\u000a	_setContainment: function() {\u000a\u000a		var o = this.options;\u000a		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;\u000a		if(o.containment == 'document' || o.containment == 'window') this.containment = [\u000a			0 - this.offset.relative.left - this.offset.parent.left,\u000a			0 - this.offset.relative.top - this.offset.parent.top,\u000a			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,\u000a			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\u000a		];\u000a\u000a		if(!(/^(document|window|parent)$/).test(o.containment)) {\u000a			var ce = $(o.containment)[0];\u000a			var co = $(o.containment).offset();\u000a			var over = ($(ce).css("overflow") != 'hidden');\u000a\u000a			this.containment = [\u000a				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,\u000a				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,\u000a				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,\u000a				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top\u000a			];\u000a		}\u000a\u000a	},\u000a\u000a	_convertPositionTo: function(d, pos) {\u000a\u000a		if(!pos) pos = this.position;\u000a		var mod = d == "absolute" ? 1 : -1;\u000a		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\u000a\u000a		return {\u000a			top: (\u000a				pos.top																	// The absolute mouse position\u000a				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)\u000a				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\u000a			),\u000a			left: (\u000a				pos.left																// The absolute mouse position\u000a				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)\u000a				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_generatePosition: function(event) {\u000a\u000a		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\u000a\u000a		// This is another very weird special case that only happens for relative elements:\u000a		// 1. If the css position is relative\u000a		// 2. and the scroll parent is the document or similar to the offset parent\u000a		// we have to refresh the relative offset during the scroll so there are no jumps\u000a		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {\u000a			this.offset.relative = this._getRelativeOffset();\u000a		}\u000a\u000a		var pageX = event.pageX;\u000a		var pageY = event.pageY;\u000a\u000a		/*\u000a		 * - Position constraining -\u000a		 * Constrain the position to a mix of grid, containment.\u000a		 */\u000a\u000a		if(this.originalPosition) { //If we are not dragging yet, we won't check for options\u000a\u000a			if(this.containment) {\u000a				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;\u000a				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;\u000a				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;\u000a				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;\u000a			}\u000a\u000a			if(o.grid) {\u000a				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\u000a				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\u000a\u000a				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\u000a				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\u000a			}\u000a\u000a		}\u000a\u000a		return {\u000a			top: (\u000a				pageY																// The absolute mouse position\u000a				- this.offset.click.top													// Click offset (relative to the element)\u000a				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)\u000a				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\u000a			),\u000a			left: (\u000a				pageX																// The absolute mouse position\u000a				- this.offset.click.left												// Click offset (relative to the element)\u000a				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)\u000a				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_rearrange: function(event, i, a, hardRefresh) {\u000a\u000a		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));\u000a\u000a		//Various things done here to improve the performance:\u000a		// 1. we create a setTimeout, that calls refreshPositions\u000a		// 2. on the instance, we have a counter variable, that get's higher after every append\u000a		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\u000a		// 4. this lets only the last addition to the timeout stack through\u000a		this.counter = this.counter ? ++this.counter : 1;\u000a		var counter = this.counter;\u000a\u000a		this._delay(function() {\u000a			if(counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\u000a		});\u000a\u000a	},\u000a\u000a	_clear: function(event, noPropagation) {\u000a\u000a		this.reverting = false;\u000a		// We delay all events that have to be triggered to after the point where the placeholder has been removed and\u000a		// everything else normalized again\u000a		var delayedTriggers = [];\u000a\u000a		// We first have to update the dom position of the actual currentItem\u000a		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\u000a		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);\u000a		this._noFinalSort = null;\u000a\u000a		if(this.helper[0] == this.currentItem[0]) {\u000a			for(var i in this._storedCSS) {\u000a				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';\u000a			}\u000a			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\u000a		} else {\u000a			this.currentItem.show();\u000a		}\u000a\u000a		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });\u000a		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\u000a\u000a		// Check if the items Container has Changed and trigger appropriate\u000a		// events.\u000a		if (this !== this.currentContainer) {\u000a			if(!noPropagation) {\u000a				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });\u000a				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\u000a				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\u000a			}\u000a		}\u000a\u000a\u000a		//Post events to containers\u000a		for (var i = this.containers.length - 1; i >= 0; i--){\u000a			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\u000a			if(this.containers[i].containerCache.over) {\u000a				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\u000a				this.containers[i].containerCache.over = 0;\u000a			}\u000a		}\u000a\u000a		//Do what was originally in plugins\u000a		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor\u000a		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity\u000a		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index\u000a\u000a		this.dragging = false;\u000a		if(this.cancelHelperRemoval) {\u000a			if(!noPropagation) {\u000a				this._trigger("beforeStop", event, this._uiHash());\u000a				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events\u000a				this._trigger("stop", event, this._uiHash());\u000a			}\u000a\u000a			this.fromOutside = false;\u000a			return false;\u000a		}\u000a\u000a		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());\u000a\u000a		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\u000a		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\u000a\u000a		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;\u000a\u000a		if(!noPropagation) {\u000a			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events\u000a			this._trigger("stop", event, this._uiHash());\u000a		}\u000a\u000a		this.fromOutside = false;\u000a		return true;\u000a\u000a	},\u000a\u000a	_trigger: function() {\u000a		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\u000a			this.cancel();\u000a		}\u000a	},\u000a\u000a	_uiHash: function(_inst) {\u000a		var inst = _inst || this;\u000a		return {\u000a			helper: inst.helper,\u000a			placeholder: inst.placeholder || $([]),\u000a			position: inst.position,\u000a			originalPosition: inst.originalPosition,\u000a			offset: inst.positionAbs,\u000a			item: inst.currentItem,\u000a			sender: _inst ? _inst.element : null\u000a		};\u000a	}\u000a\u000a});\u000a\u000a})(jQuery);\u000a\u000a;\u000a
p0
.