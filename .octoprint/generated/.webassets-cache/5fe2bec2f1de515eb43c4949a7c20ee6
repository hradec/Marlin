V/**\u000a * User: hudbrog (hudbrog@gmail.com)\u000a * Date: 10/20/12\u000a * Time: 1:36 PM\u000a * To change this template use File | Settings | File Templates.\u000a */\u000a\u000a\u000aGCODE.renderer = (function(){\u000a// ***** PRIVATE ******\u000a    var canvas;\u000a    var ctx;\u000a    var zoomFactor= 2.8, zoomFactorDelta = 0.4;\u000a    var gridStep=10;\u000a    var ctxHeight, ctxWidth;\u000a    var prevX=0, prevY=0;\u000a    var pixelRatio = window.devicePixelRatio || 1;\u000a\u000a    var layerNumStore, progressStore={from: 0, to: -1};\u000a    var lastX, lastY;\u000a    var dragStart, dragged;\u000a    var scaleFactor = 1.1;\u000a    var model;\u000a    var initialized = false;\u000a    var renderOptions = {\u000a        colorGrid: "#bbbbbb",\u000a        bgColorGrid: "#ffffff",\u000a        bgColorOffGrid: "#eeeeee",\u000a        colorLine: ["#000000", "#3333cc", "#cc3333", "#33cc33", "#cc33cc"],\u000a        colorMove: "#00ff00",\u000a        colorRetract: "#ff0000",\u000a        colorRestart: "#0000ff",\u000a\u000a        showMoves: true,\u000a        showRetracts: true,\u000a        extrusionWidth: 1 * pixelRatio,\u000a        // #000000", "#45c7ba",  "#a9533a", "#ff44cc", "#dd1177", "#eeee22", "#ffbb55", "#ff5511", "#777788"\u000a        sizeRetractSpot: 2 * pixelRatio,\u000a        modelCenter: {x: 0, y: 0},\u000a        differentiateColors: true,\u000a        showNextLayer: false,\u000a        showPreviousLayer: false,\u000a\u000a        moveModel: true,\u000a        zoomInOnModel: false,\u000a        zoomInOnBed: false,\u000a        centerViewport: false,\u000a        invertAxes: {x: false, y: false},\u000a\u000a        bed: {x: 200, y: 200},\u000a        container: undefined,\u000a\u000a        onInternalOptionChange: undefined\u000a    };\u000a\u000a    var offsetModelX = 0, offsetModelY = 0;\u000a    var offsetBedX = 0, offsetBedY = 0;\u000a    var scaleX = 1, scaleY = 1;\u000a    var speeds = [];\u000a    var speedsByLayer = {};\u000a    var currentInvertX = false, currentInvertY = false;\u000a\u000a    var reRender = function(){\u000a        var p1 = ctx.transformedPoint(0,0);\u000a        var p2 = ctx.transformedPoint(canvas.width,canvas.height);\u000a        ctx.clearRect(p1.x,p1.y,p2.x-p1.x,p2.y-p1.y);\u000a        drawGrid();\u000a        if(renderOptions['showNextLayer'] && layerNumStore < model.length - 1) {\u000a            drawLayer(layerNumStore + 1, 0, GCODE.renderer.getLayerNumSegments(layerNumStore + 1), true);\u000a        }\u000a        if (renderOptions['showPreviousLayer'] && layerNumStore > 0) {\u000a            drawLayer(layerNumStore - 1, 0, GCODE.renderer.getLayerNumSegments(layerNumStore - 1), true);\u000a        }\u000a        drawLayer(layerNumStore, progressStore.from, progressStore.to);\u000a    };\u000a\u000a    function trackTransforms(ctx){\u000a        var svg = document.createElementNS("http://www.w3.org/2000/svg",'svg');\u000a        var xform = svg.createSVGMatrix();\u000a        ctx.getTransform = function(){ return xform; };\u000a\u000a        var savedTransforms = [];\u000a        var save = ctx.save;\u000a        ctx.save = function(){\u000a            savedTransforms.push(xform.translate(0,0));\u000a            return save.call(ctx);\u000a        };\u000a        var restore = ctx.restore;\u000a        ctx.restore = function(){\u000a            xform = savedTransforms.pop();\u000a            return restore.call(ctx);\u000a        };\u000a\u000a        var scale = ctx.scale;\u000a        ctx.scale = function(sx,sy){\u000a            xform = xform.scaleNonUniform(sx,sy);\u000a            return scale.call(ctx,sx,sy);\u000a        };\u000a        var rotate = ctx.rotate;\u000a        ctx.rotate = function(radians){\u000a            xform = xform.rotate(radians*180/Math.PI);\u000a            return rotate.call(ctx,radians);\u000a        };\u000a        var translate = ctx.translate;\u000a        ctx.translate = function(dx,dy){\u000a            xform = xform.translate(dx,dy);\u000a            return translate.call(ctx,dx,dy);\u000a        };\u000a        var transform = ctx.transform;\u000a        ctx.transform = function(a,b,c,d,e,f){\u000a            var m2 = svg.createSVGMatrix();\u000a            m2.a=a; m2.b=b; m2.c=c; m2.d=d; m2.e=e; m2.f=f;\u000a            xform = xform.multiply(m2);\u000a            return transform.call(ctx,a,b,c,d,e,f);\u000a        };\u000a        var setTransform = ctx.setTransform;\u000a        ctx.setTransform = function(a,b,c,d,e,f){\u000a            xform.a = a;\u000a            xform.b = b;\u000a            xform.c = c;\u000a            xform.d = d;\u000a            xform.e = e;\u000a            xform.f = f;\u000a            return setTransform.call(ctx,a,b,c,d,e,f);\u000a        };\u000a        var pt  = svg.createSVGPoint();\u000a        ctx.transformedPoint = function(x,y){\u000a            pt.x=x; pt.y=y;\u000a            return pt.matrixTransform(xform.inverse());\u000a        }\u000a    }\u000a\u000a\u000a    var  startCanvas = function() {\u000a        var jqueryCanvas = $(renderOptions["container"]);\u000a        //jqueryCanvas.css("background-color", renderOptions["bgColorOffGrid"]);\u000a        canvas = jqueryCanvas[0];\u000a\u000a        ctx = canvas.getContext('2d');\u000a        canvas.style.height = canvas.height + "px";\u000a        canvas.style.width = canvas.width + "px";\u000a        canvas.height = canvas.height * pixelRatio;\u000a        canvas.width = canvas.width * pixelRatio;\u000a        ctxHeight = canvas.height;\u000a        ctxWidth = canvas.width;\u000a        lastX = ctxWidth/2;\u000a        lastY = ctxHeight/2;\u000a        ctx.lineWidth = 2;\u000a        ctx.lineCap = 'round';\u000a        trackTransforms(ctx);\u000a\u000a        // dragging => translating\u000a        canvas.addEventListener('mousedown', function(event){\u000a            document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';\u000a\u000a            // remember starting point of dragging gesture\u000a            lastX = (event.offsetX || (event.pageX - canvas.offsetLeft)) * pixelRatio;\u000a            lastY = (event.offsetY || (event.pageY - canvas.offsetTop)) * pixelRatio;\u000a            dragStart = ctx.transformedPoint(lastX, lastY);\u000a\u000a            // not yet dragged anything\u000a            dragged = false;\u000a        }, false);\u000a\u000a        canvas.addEventListener('mousemove', function(event){\u000a            // save current mouse coordinates\u000a            lastX = (event.offsetX || (event.pageX - canvas.offsetLeft)) * pixelRatio;\u000a            lastY = (event.offsetY || (event.pageY - canvas.offsetTop)) * pixelRatio;\u000a\u000a            // mouse movement => dragged\u000a            dragged = true;\u000a\u000a            if (dragStart !== undefined){\u000a                // translate\u000a                var pt = ctx.transformedPoint(lastX,lastY);\u000a                ctx.translate(pt.x - dragStart.x, pt.y - dragStart.y);\u000a                reRender();\u000a\u000a                renderOptions["centerViewport"] = false;\u000a                renderOptions["zoomInOnModel"] = false;\u000a                renderOptions["zoomInOnBed"] = false;\u000a                offsetModelX = 0;\u000a                offsetModelY = 0;\u000a                offsetBedX = 0;\u000a                offsetBedY = 0;\u000a                scaleX = 1;\u000a                scaleY = 1;\u000a\u000a                if (renderOptions["onInternalOptionChange"] !== undefined) {\u000a                    renderOptions["onInternalOptionChange"]({\u000a                        centerViewport: false,\u000a                        moveModel: false,\u000a                        zoomInOnModel: false,\u000a                        zoomInOnBed: false\u000a                    });\u000a                }\u000a            }\u000a        }, false);\u000a\u000a        canvas.addEventListener('mouseup', function(event){\u000a            // reset dragStart\u000a            dragStart = undefined;\u000a        }, false);\u000a\u000a        // mouse wheel => zooming\u000a        var zoom = function(clicks){\u000a            // focus on last mouse position prior to zoom\u000a            var pt = ctx.transformedPoint(lastX, lastY);\u000a            ctx.translate(pt.x,pt.y);\u000a\u000a            // determine zooming factor and perform zoom\u000a            var factor = Math.pow(scaleFactor,clicks);\u000a            ctx.scale(factor,factor);\u000a\u000a            // return to old position\u000a            ctx.translate(-pt.x,-pt.y);\u000a\u000a            // render\u000a            reRender();\u000a\u000a            // disable conflicting options\u000a            renderOptions["zoomInOnModel"] = false;\u000a            renderOptions["zoomInOnBed"] = false;\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a\u000a            if (renderOptions["onInternalOptionChange"] !== undefined) {\u000a                renderOptions["onInternalOptionChange"]({\u000a                    zoomInOnModel: false,\u000a                    zoomInOnBed: false\u000a                });\u000a            }\u000a        };\u000a        var handleScroll = function(event){\u000a            var delta;\u000a\u000a            // determine zoom direction & delta\u000a            if (event.detail < 0 || event.wheelDelta > 0) {\u000a                delta = zoomFactorDelta;\u000a            } else {\u000a                delta = -1 * zoomFactorDelta;\u000a            }\u000a            if (delta) zoom(delta);\u000a\u000a            return event.preventDefault() && false;\u000a        };\u000a        canvas.addEventListener('DOMMouseScroll',handleScroll,false);\u000a        canvas.addEventListener('mousewheel',handleScroll,false);\u000a    };\u000a\u000a    var drawGrid = function() {\u000a        ctx.translate(offsetBedX, offsetBedY);\u000a        if(renderOptions["bed"]["circular"]) {\u000a            drawCircularGrid();\u000a        } else {\u000a            drawRectangularGrid();\u000a        }\u000a        ctx.translate(-offsetBedX, -offsetBedY);\u000a    };\u000a\u000a    var drawRectangularGrid = function() {\u000a        var x, y;\u000a        var width = renderOptions["bed"]["x"];\u000a        var height = renderOptions["bed"]["y"];\u000a\u000a        var minX, maxX, minY, maxY;\u000a        if (renderOptions["bed"]["centeredOrigin"]) {\u000a            var halfWidth = width / 2;\u000a            var halfHeight = height / 2;\u000a\u000a            minX = -halfWidth;\u000a            maxX = halfWidth;\u000a            minY = -halfHeight;\u000a            maxY = halfHeight;\u000a        } else {\u000a            minX = 0;\u000a            maxX = width;\u000a            minY = 0;\u000a            maxY = height;\u000a        }\u000a\u000a        //~ bed outline and origin\u000a        ctx.beginPath();\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.fillStyle = "#ffffff";\u000a        ctx.lineWidth = 2;\u000a\u000a        // outline\u000a        ctx.rect(minX * zoomFactor, -1 * minY * zoomFactor, width * zoomFactor, -1 * height * zoomFactor);\u000a\u000a        // origin\u000a        ctx.moveTo(minX * zoomFactor, 0);\u000a        ctx.lineTo(maxX * zoomFactor, 0);\u000a        ctx.moveTo(0, -1 * minY * zoomFactor);\u000a        ctx.lineTo(0, -1 * maxY * zoomFactor);\u000a\u000a        // draw\u000a        ctx.fill();\u000a        ctx.stroke();\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.lineWidth = 1;\u000a\u000a        //~~ grid starting from origin\u000a        ctx.beginPath();\u000a        for (x = 0; x <= maxX; x += gridStep) {\u000a            ctx.moveTo(x * zoomFactor, -1 * minY * zoomFactor);\u000a            ctx.lineTo(x * zoomFactor, -1 * maxY * zoomFactor);\u000a\u000a            if (renderOptions["bed"]["centeredOrigin"]) {\u000a                ctx.moveTo(-1 * x * zoomFactor, -1 * minY * zoomFactor);\u000a                ctx.lineTo(-1 * x * zoomFactor, -1 * maxY * zoomFactor);\u000a            }\u000a        }\u000a        ctx.stroke();\u000a\u000a        ctx.beginPath();\u000a        for (y = 0; y <= maxY; y += gridStep) {\u000a            ctx.moveTo(minX * zoomFactor, -1 * y * zoomFactor);\u000a            ctx.lineTo(maxX * zoomFactor, -1 * y * zoomFactor);\u000a\u000a            if (renderOptions["bed"]["centeredOrigin"]) {\u000a                ctx.moveTo(minX * zoomFactor, y * zoomFactor);\u000a                ctx.lineTo(maxX * zoomFactor, y * zoomFactor);\u000a            }\u000a        }\u000a        ctx.stroke();\u000a    };\u000a\u000a    var drawCircularGrid = function() {\u000a        var i;\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.fillStyle = "#ffffff";\u000a        ctx.lineWidth = 2;\u000a\u000a        //~~ bed outline & origin\u000a        ctx.beginPath();\u000a\u000a        // outline\u000a        ctx.arc(0, 0, renderOptions["bed"]["r"] * zoomFactor, 0, Math.PI * 2, true);\u000a\u000a        // origin\u000a        ctx.moveTo(-1 * renderOptions["bed"]["r"] * zoomFactor, 0);\u000a        ctx.lineTo(renderOptions["bed"]["r"] * zoomFactor, 0);\u000a        ctx.moveTo(0, -1 * renderOptions["bed"]["r"] * zoomFactor);\u000a        ctx.lineTo(0, renderOptions["bed"]["r"] * zoomFactor);\u000a\u000a        // draw\u000a        ctx.fill();\u000a        ctx.stroke();\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.lineWidth = 1;\u000a\u000a        //~~ grid starting from origin\u000a        ctx.beginPath();\u000a        for (i = 0; i <= renderOptions["bed"]["r"]; i += gridStep) {\u000a            var x = i;\u000a            var y = Math.sqrt(Math.pow(renderOptions["bed"]["r"], 2) - Math.pow(x, 2));\u000a\u000a            ctx.moveTo(x * zoomFactor, y * zoomFactor);\u000a            ctx.lineTo(x * zoomFactor, -1 * y * zoomFactor);\u000a\u000a            ctx.moveTo(y * zoomFactor, x * zoomFactor);\u000a            ctx.lineTo(-1 * y * zoomFactor, x * zoomFactor);\u000a\u000a            ctx.moveTo(-1 * x * zoomFactor, y * zoomFactor);\u000a            ctx.lineTo(-1 * x * zoomFactor, -1 * y * zoomFactor);\u000a\u000a            ctx.moveTo(y * zoomFactor, -1 * x * zoomFactor);\u000a            ctx.lineTo(-1 * y * zoomFactor, -1 * x * zoomFactor);\u000a        }\u000a        ctx.stroke();\u000a    };\u000a\u000a    var drawLayer = function(layerNum, fromProgress, toProgress, isNotCurrentLayer){\u000a        log.trace("Drawing layer " + layerNum + " from " + fromProgress + " to " + toProgress + " (current: " + !isNotCurrentLayer + ")");\u000a\u000a        var i;\u000a\u000a        //~~ store current layer values\u000a\u000a        isNotCurrentLayer = isNotCurrentLayer !== undefined ? isNotCurrentLayer : false;\u000a        if (!isNotCurrentLayer) {\u000a            // not not current layer == current layer => store layer number and from/to progress\u000a            layerNumStore = layerNum;\u000a            progressStore = {from: fromProgress, to: toProgress};\u000a        }\u000a\u000a        if (!model || !model[layerNum]) return;\u000a\u000a        var cmds = model[layerNum];\u000a        var x, y;\u000a\u000a        //~~ find our initial prevX/prevY tuple\u000a\u000a        if (cmds[0].prevX !== undefined && cmds[0].prevY !== undefined) {\u000a            // command contains prevX/prevY values, use those\u000a            prevX = cmds[0].prevX * zoomFactor;\u000a            prevY = -1 * cmds[0].prevY * zoomFactor;\u000a        } else if (fromProgress > 0) {\u000a            // previous command in same layer exists, use x/y as prevX/prevY\u000a            prevX = cmds[fromProgress - 1].x * zoomFactor;\u000a            prevY = -cmds[fromProgress - 1].y * zoomFactor;\u000a        } else if (model[layerNum - 1]) {\u000a            // previous layer exists, use last x/y as prevX/prevY\u000a            prevX = undefined;\u000a            prevY = undefined;\u000a            for (i = model[layerNum-1].length-1; i >= 0; i--) {\u000a                if (prevX === undefined && model[layerNum - 1][i].x !== undefined) prevX = model[layerNum - 1][i].x * zoomFactor;\u000a                if (prevY === undefined && model[layerNum - 1][i].y !== undefined) prevY =- model[layerNum - 1][i].y * zoomFactor;\u000a            }\u000a        }\u000a\u000a        // if we did not find prevX or prevY, set it to 0 (might be that we are on the first command of the first layer,\u000a        // or it's just a very weird model...)\u000a        if (prevX === undefined) prevX = 0;\u000a        if (prevY === undefined) prevY = 0;\u000a\u000a        //~~ render this layer's commands\u000a\u000a        for (i = fromProgress; i <= toProgress; i++) {\u000a            ctx.lineWidth = 1;\u000a\u000a            if (typeof(cmds[i]) === 'undefined') continue;\u000a\u000a            if (typeof(cmds[i].prevX) !== 'undefined' && typeof(cmds[i].prevY) !== 'undefined') {\u000a                // override new (prevX, prevY)\u000a                prevX = cmds[i].prevX * zoomFactor;\u000a                prevY = -1 * cmds[i].prevY * zoomFactor;\u000a            }\u000a\u000a            // new x\u000a            if (typeof(cmds[i].x) === 'undefined' || isNaN(cmds[i].x)) {\u000a                x = prevX / zoomFactor;\u000a            } else {\u000a                x = cmds[i].x;\u000a            }\u000a\u000a            // new y\u000a            if (typeof(cmds[i].y) === 'undefined' || isNaN(cmds[i].y)) {\u000a                y = prevY / zoomFactor;\u000a            } else {\u000a                y = -cmds[i].y;\u000a            }\u000a\u000a            // current tool\u000a            var tool = cmds[i].tool;\u000a            if (tool === undefined) tool = 0;\u000a\u000a            // line color based on tool\u000a            var lineColor = renderOptions["colorLine"][tool];\u000a            if (lineColor === undefined) lineColor = renderOptions["colorLine"][0];\u000a\u000a            // alpha value (100% if current layer is being rendered, 30% otherwise)\u000a            var alpha = (renderOptions['showNextLayer'] || renderOptions['showPreviousLayer']) && isNotCurrentLayer ? 0.3 : 1.0;\u000a            var shade = tool * 0.15;\u000a\u000a            if (!cmds[i].extrude && !cmds[i].noMove) {\u000a                // neither extrusion nor move\u000a                if (cmds[i].retract == -1) {\u000a                    // retract => draw dot if configured to do so\u000a                    if (renderOptions["showRetracts"]) {\u000a                        ctx.strokeStyle = pusher.color(renderOptions["colorRetract"]).shade(shade).alpha(alpha).html();\u000a                        ctx.fillStyle = pusher.color(renderOptions["colorRetract"]).shade(shade).alpha(alpha).html();\u000a                        ctx.beginPath();\u000a                        ctx.arc(prevX, prevY, renderOptions["sizeRetractSpot"], 0, Math.PI*2, true);\u000a                        ctx.stroke();\u000a                        ctx.fill();\u000a                    }\u000a                }\u000a\u000a                if(renderOptions["showMoves"]){\u000a                    // move => draw line from (prevX, prevY) to (x, y) in move color\u000a                    ctx.strokeStyle = pusher.color(renderOptions["colorMove"]).shade(shade).alpha(alpha).html();\u000a                    ctx.beginPath();\u000a                    ctx.moveTo(prevX, prevY);\u000a                    ctx.lineTo(x*zoomFactor,y*zoomFactor);\u000a                    ctx.stroke();\u000a                }\u000a            } else if(cmds[i].extrude) {\u000a                if (cmds[i].retract == 0) {\u000a                    // no retraction => real extrusion move, use tool color to draw line\u000a                    ctx.strokeStyle = pusher.color(renderOptions["colorLine"][tool]).shade(shade).alpha(alpha).html();\u000a                    ctx.lineWidth = renderOptions['extrusionWidth'];\u000a                    ctx.beginPath();\u000a                    ctx.moveTo(prevX, prevY);\u000a                    ctx.lineTo(x*zoomFactor,y*zoomFactor);\u000a                    ctx.stroke();\u000a                } else {\u000a                    // we were previously retracting, now we are restarting => draw dot if configured to do so\u000a                    if (renderOptions["showRetracts"]) {\u000a                        ctx.strokeStyle = pusher.color(renderOptions["colorRestart"]).shade(shade).alpha(alpha).html();\u000a                        ctx.fillStyle = pusher.color(renderOptions["colorRestart"]).shade(shade).alpha(alpha).html();\u000a                        ctx.beginPath();\u000a                        ctx.arc(prevX, prevY, renderOptions["sizeRetractSpot"], 0, Math.PI*2, true);\u000a                        ctx.stroke();\u000a                        ctx.fill();\u000a                    }\u000a                }\u000a            }\u000a\u000a            // set new (prevX, prevY)\u000a            prevX = x * zoomFactor;\u000a            prevY = y * zoomFactor;\u000a        }\u000a        ctx.stroke();\u000a    };\u000a\u000a    var applyOffsets = function(mdlInfo) {\u000a        var canvasCenter;\u000a\u000a        // determine bed and model offsets\u000a        if (ctx) ctx.translate(-offsetModelX, -offsetModelY);\u000a        if (renderOptions["centerViewport"] || renderOptions["zoomInOnModel"]) {\u000a            canvasCenter = ctx.transformedPoint(canvas.width / 2, canvas.height / 2);\u000a            if (mdlInfo) {\u000a                offsetModelX = canvasCenter.x - (mdlInfo.min.x + mdlInfo.modelSize.x / 2) * zoomFactor;\u000a                offsetModelY = canvasCenter.y + (mdlInfo.min.y + mdlInfo.modelSize.y / 2) * zoomFactor;\u000a            } else {\u000a                offsetModelX = 0;\u000a                offsetModelY = 0;\u000a            }\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        } else if (mdlInfo && renderOptions["moveModel"]) {\u000a            offsetModelX = (renderOptions["bed"]["x"] / 2 - (mdlInfo.min.x + mdlInfo.modelSize.x / 2)) * zoomFactor;\u000a            offsetModelY = -1 * (renderOptions["bed"]["y"] / 2 - (mdlInfo.min.y + mdlInfo.modelSize.y / 2)) * zoomFactor;\u000a            offsetBedX = -1 * (renderOptions["bed"]["x"] / 2 - (mdlInfo.min.x + mdlInfo.modelSize.x / 2)) * zoomFactor;\u000a            offsetBedY = (renderOptions["bed"]["y"] / 2 - (mdlInfo.min.y + mdlInfo.modelSize.y / 2)) * zoomFactor;\u000a        } else if (renderOptions["bed"]["circular"] || renderOptions["bed"]["centeredOrigin"]) {\u000a            canvasCenter = ctx.transformedPoint(canvas.width / 2, canvas.height / 2);\u000a            offsetModelX = canvasCenter.x;\u000a            offsetModelY = canvasCenter.y;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        } else {\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        }\u000a        if (ctx) ctx.translate(offsetModelX, offsetModelY);\u000a    };\u000a\u000a    var applyZoom = function(mdlInfo) {\u000a        // get middle of canvas\u000a        var pt = ctx.transformedPoint(canvas.width/2,canvas.height/2);\u000a\u000a        // get current transform\u000a        var transform = ctx.getTransform();\u000a\u000a        // move to middle of canvas, reset scale, move back\u000a        if (scaleX && scaleY && transform.a && transform.d) {\u000a            ctx.translate(pt.x, pt.y);\u000a            ctx.scale(1 / scaleX, 1 / scaleY);\u000a            ctx.translate(-pt.x, -pt.y);\u000a            transform = ctx.getTransform();\u000a        }\u000a\u000a        if (mdlInfo && renderOptions["zoomInOnModel"]) {\u000a            // if we need to zoom in on model, scale factor is calculated by longer side of object in relation to that axis of canvas\u000a            var scaleF = mdlInfo.modelSize.x > mdlInfo.modelSize.y ? (canvas.width - 10) / mdlInfo.modelSize.x : (canvas.height - 10) / mdlInfo.modelSize.y;\u000a            scaleF /= zoomFactor;\u000a            if (transform.a && transform.d) {\u000a                scaleX = scaleF / transform.a * (renderOptions["invertAxes"]["x"] ? -1 : 1);\u000a                scaleY = scaleF / transform.d * (renderOptions["invertAxes"]["y"] ? -1 : 1);\u000a                ctx.translate(pt.x,pt.y);\u000a                ctx.scale(scaleX, scaleY);\u000a                ctx.translate(-pt.x, -pt.y);\u000a            }\u000a        } else {\u000a            // reset scale to 1\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a        }\u000a    };\u000a\u000a    var applyInversion = function() {\u000a        var width = canvas.width - 10;\u000a        var height = canvas.height - 10;\u000a\u000a        // de-invert\u000a        if (currentInvertX || currentInvertY) {\u000a            ctx.scale(currentInvertX ? -1 : 1, currentInvertY ? -1 : 1);\u000a            ctx.translate(currentInvertX ? -width : 0, currentInvertY ? height : 0);\u000a        }\u000a\u000a        // get settings\u000a        var invertX = renderOptions["invertAxes"]["x"];\u000a        var invertY = renderOptions["invertAxes"]["y"];\u000a\u000a        // invert\u000a        if (invertX || invertY) {\u000a            ctx.translate(invertX ? width : 0, invertY ? -height : 0);\u000a            ctx.scale(invertX ? -1 : 1, invertY ? -1 : 1);\u000a        }\u000a\u000a        // save for later\u000a        currentInvertX = invertX;\u000a        currentInvertY = invertY;\u000a    };\u000a\u000a// ***** PUBLIC *******\u000a    return {\u000a        init: function(){\u000a            startCanvas();\u000a            initialized = true;\u000a            var bedWidth = renderOptions["bed"]["x"];\u000a            var bedHeight = renderOptions["bed"]["y"];\u000a            if(renderOptions["bed"]["circular"]) {\u000a                bedWidth = bedHeight = renderOptions["bed"]["r"] * 2;\u000a            }\u000a            zoomFactor = Math.min((canvas.width - 10) / bedWidth, (canvas.height - 10) / bedHeight);\u000a\u000a            var translationX, translationY;\u000a            if (renderOptions["bed"]["circular"]) {\u000a                translationX = canvas.width / 2;\u000a                translationY = canvas.height / 2;\u000a            } else {\u000a                translationX = (canvas.width - bedWidth * zoomFactor) / 2;\u000a                translationY = bedHeight * zoomFactor + (canvas.height - bedHeight * zoomFactor) / 2;\u000a            }\u000a            ctx.translate(translationX, translationY);\u000a\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        },\u000a        setOption: function(options){\u000a            var mustRefresh = false;\u000a            var dirty = false;\u000a            for (var opt in options) {\u000a                if (!renderOptions.hasOwnProperty(opt) || !options.hasOwnProperty(opt)) continue;\u000a                if (options[opt] === undefined) continue;\u000a                if (renderOptions[opt] == options[opt]) continue;\u000a\u000a                dirty = true;\u000a                renderOptions[opt] = options[opt];\u000a                if ($.inArray(opt, ["moveModel", "centerViewport", "zoomInOnModel", "bed", "invertAxes"]) > -1) {\u000a                    mustRefresh = true;\u000a                }\u000a            }\u000a\u000a            if (!dirty) return;\u000a            if(initialized) {\u000a                if (mustRefresh) {\u000a                    this.refresh();\u000a                } else {\u000a                    reRender();\u000a                }\u000a            }\u000a        },\u000a        getOptions: function(){\u000a            return renderOptions;\u000a        },\u000a        debugGetModel: function(){\u000a            return model;\u000a        },\u000a        render: function(layerNum, fromProgress, toProgress){\u000a            if (!initialized) this.init();\u000a\u000a            var p1 = ctx.transformedPoint(0, 0);\u000a            var p2 = ctx.transformedPoint(canvas.width, canvas.height);\u000a            ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);\u000a            drawGrid();\u000a            if (model && model.length) {\u000a                if (layerNum < model.length) {\u000a                    if (renderOptions['showNextLayer'] && layerNum < model.length - 1) {\u000a                        drawLayer(layerNum + 1, 0, this.getLayerNumSegments(layerNum + 1), true);\u000a                    }\u000a                    if (renderOptions['showPreviousLayer'] && layerNum > 0) {\u000a                        drawLayer(layerNum - 1, 0, this.getLayerNumSegments(layerNum - 1), true);\u000a                    }\u000a                    drawLayer(layerNum, fromProgress, toProgress);\u000a                } else {\u000a                    console.log("Got request to render non-existent layer");\u000a                }\u000a            }\u000a        },\u000a        getModelNumLayers: function(){\u000a            return model ? model.length : 1;\u000a        },\u000a        getLayerNumSegments: function(layer){\u000a            if(model){\u000a                return model[layer]?model[layer].length:1;\u000a            }else{\u000a                return 1;\u000a            }\u000a        },\u000a        clear: function() {\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a            speeds = [];\u000a            speedsByLayer = {};\u000a\u000a            this.doRender([], 0);\u000a        },\u000a        doRender: function(mdl, layerNum){\u000a            model = mdl;\u000a\u000a            var mdlInfo = undefined;\u000a            prevX = 0;\u000a            prevY = 0;\u000a            if (!initialized) this.init();\u000a\u000a            var toProgress = 1;\u000a            if (model) {\u000a                mdlInfo = GCODE.gCodeReader.getModelInfo();\u000a                speeds = mdlInfo.speeds;\u000a                speedsByLayer = mdlInfo.speedsByLayer;\u000a                if (model[layerNum]) {\u000a                    toProgress = model[layerNum].length;\u000a                }\u000a            }\u000a\u000a            applyInversion();\u000a            applyOffsets(mdlInfo);\u000a            applyZoom(mdlInfo);\u000a\u000a            this.render(layerNum, 0, toProgress);\u000a        },\u000a        refresh: function(layerNum) {\u000a            if (!layerNum) layerNum = layerNumStore;\u000a            this.doRender(model, layerNum);\u000a        },\u000a        getZ: function(layerNum){\u000a            if(!model || !model[layerNum]){\u000a                return '-1';\u000a            }\u000a            var cmds = model[layerNum];\u000a            for(var i = 0; i < cmds.length; i++){\u000a                if(cmds[i].prevZ !== undefined) return cmds[i].prevZ;\u000a            }\u000a            return '-1';\u000a        }\u000a\u000a}\u000a}());\u000a\u000a;\u000a
p0
.