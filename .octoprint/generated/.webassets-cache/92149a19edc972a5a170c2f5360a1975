V// source: plugin/yamlpatcher/js/jsdiff.js\u000a/*\u000a * Software License Agreement (BSD License)\u000a *\u000a * Copyright (c) 2009-2011, Kevin Decker kpdecker@gmail.com\u000a *\u000a * All rights reserved.\u000a *\u000a * Redistribution and use of this software in source and binary forms, with or\u000a * without modification, are permitted provided that the following conditions\u000a * are met:\u000a *\u000a *   * Redistributions of source code must retain the above copyright notice,\u000a *     this list of conditions and the following disclaimer.\u000a *\u000a *   * Redistributions in binary form must reproduce the above copyright notice,\u000a *     this list of conditions and the following disclaimer in the documentation\u000a *     and/or other materials provided with the distribution.\u000a *\u000a *   * Neither the name of Kevin Decker nor the names of its contributors may\u000a *     be used to endorse or promote products derived from this software without\u000a *     specific prior written permission.\u000a *\u000a * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\u000a * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\u000a * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\u000a * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\u000a * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\u000a * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\u000a * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\u000a * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\u000a * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\u000a * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\u000a * POSSIBILITY OF SUCH DAMAGE.\u000a */\u000a\u000a/*\u000a * Text diff implementation.\u000a *\u000a * This library supports the following APIS:\u000a * JsDiff.diffChars: Character by character diff\u000a * JsDiff.diffWords: Word (as defined by \u005cb regex) diff which ignores whitespace\u000a * JsDiff.diffLines: Line based diff\u000a *\u000a * JsDiff.diffCss: Diff targeted at CSS content\u000a *\u000a * These methods are based on the implementation proposed in\u000a * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).\u000a * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\u000a */\u000a(function(global, undefined) {\u000a    var objectPrototypeToString = Object.prototype.toString;\u000a\u000a    /*istanbul ignore next*/\u000a    function map(arr, mapper, that) {\u000a        if (Array.prototype.map) {\u000a            return Array.prototype.map.call(arr, mapper, that);\u000a        }\u000a\u000a        var other = new Array(arr.length);\u000a\u000a        for (var i = 0, n = arr.length; i < n; i++) {\u000a            other[i] = mapper.call(that, arr[i], i, arr);\u000a        }\u000a        return other;\u000a    }\u000a    function clonePath(path) {\u000a        return { newPos: path.newPos, components: path.components.slice(0) };\u000a    }\u000a    function removeEmpty(array) {\u000a        var ret = [];\u000a        for (var i = 0; i < array.length; i++) {\u000a            if (array[i]) {\u000a                ret.push(array[i]);\u000a            }\u000a        }\u000a        return ret;\u000a    }\u000a    function escapeHTML(s) {\u000a        var n = s;\u000a        n = n.replace(/&/g, '&amp;');\u000a        n = n.replace(/</g, '&lt;');\u000a        n = n.replace(/>/g, '&gt;');\u000a        n = n.replace(/"/g, '&quot;');\u000a\u000a        return n;\u000a    }\u000a\u000a    // This function handles the presence of circular references by bailing out when encountering an\u000a    // object that is already on the "stack" of items being processed.\u000a    function canonicalize(obj, stack, replacementStack) {\u000a        stack = stack || [];\u000a        replacementStack = replacementStack || [];\u000a\u000a        var i;\u000a\u000a        for (i = 0; i < stack.length; i += 1) {\u000a            if (stack[i] === obj) {\u000a                return replacementStack[i];\u000a            }\u000a        }\u000a\u000a        var canonicalizedObj;\u000a\u000a        if ('[object Array]' === objectPrototypeToString.call(obj)) {\u000a            stack.push(obj);\u000a            canonicalizedObj = new Array(obj.length);\u000a            replacementStack.push(canonicalizedObj);\u000a            for (i = 0; i < obj.length; i += 1) {\u000a                canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\u000a            }\u000a            stack.pop();\u000a            replacementStack.pop();\u000a        } else if (typeof obj === 'object' && obj !== null) {\u000a            stack.push(obj);\u000a            canonicalizedObj = {};\u000a            replacementStack.push(canonicalizedObj);\u000a            var sortedKeys = [],\u000a                key;\u000a            for (key in obj) {\u000a                sortedKeys.push(key);\u000a            }\u000a            sortedKeys.sort();\u000a            for (i = 0; i < sortedKeys.length; i += 1) {\u000a                key = sortedKeys[i];\u000a                canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\u000a            }\u000a            stack.pop();\u000a            replacementStack.pop();\u000a        } else {\u000a            canonicalizedObj = obj;\u000a        }\u000a        return canonicalizedObj;\u000a    }\u000a\u000a    function buildValues(components, newString, oldString, useLongestToken) {\u000a        var componentPos = 0,\u000a            componentLen = components.length,\u000a            newPos = 0,\u000a            oldPos = 0;\u000a\u000a        for (; componentPos < componentLen; componentPos++) {\u000a            var component = components[componentPos];\u000a            if (!component.removed) {\u000a                if (!component.added && useLongestToken) {\u000a                    var value = newString.slice(newPos, newPos + component.count);\u000a                    value = map(value, function(value, i) {\u000a                        var oldValue = oldString[oldPos + i];\u000a                        return oldValue.length > value.length ? oldValue : value;\u000a                    });\u000a\u000a                    component.value = value.join('');\u000a                } else {\u000a                    component.value = newString.slice(newPos, newPos + component.count).join('');\u000a                }\u000a                newPos += component.count;\u000a\u000a                // Common case\u000a                if (!component.added) {\u000a                    oldPos += component.count;\u000a                }\u000a            } else {\u000a                component.value = oldString.slice(oldPos, oldPos + component.count).join('');\u000a                oldPos += component.count;\u000a\u000a                // Reverse add and remove so removes are output first to match common convention\u000a                // The diffing algorithm is tied to add then remove output and this is the simplest\u000a                // route to get the desired output with minimal overhead.\u000a                if (componentPos && components[componentPos - 1].added) {\u000a                    var tmp = components[componentPos - 1];\u000a                    components[componentPos - 1] = components[componentPos];\u000a                    components[componentPos] = tmp;\u000a                }\u000a            }\u000a        }\u000a\u000a        return components;\u000a    }\u000a\u000a    function Diff(ignoreWhitespace) {\u000a        this.ignoreWhitespace = ignoreWhitespace;\u000a    }\u000a    Diff.prototype = {\u000a        diff: function(oldString, newString, callback) {\u000a            var self = this;\u000a\u000a            function done(value) {\u000a                if (callback) {\u000a                    setTimeout(function() { callback(undefined, value); }, 0);\u000a                    return true;\u000a                } else {\u000a                    return value;\u000a                }\u000a            }\u000a\u000a            // Handle the identity case (this is due to unrolling editLength == 0\u000a            if (newString === oldString) {\u000a                return done([{ value: newString }]);\u000a            }\u000a            if (!newString) {\u000a                return done([{ value: oldString, removed: true }]);\u000a            }\u000a            if (!oldString) {\u000a                return done([{ value: newString, added: true }]);\u000a            }\u000a\u000a            newString = this.tokenize(newString);\u000a            oldString = this.tokenize(oldString);\u000a\u000a            var newLen = newString.length, oldLen = oldString.length;\u000a            var editLength = 1;\u000a            var maxEditLength = newLen + oldLen;\u000a            var bestPath = [{ newPos: -1, components: [] }];\u000a\u000a            // Seed editLength = 0, i.e. the content starts with the same values\u000a            var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\u000a            if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\u000a                // Identity per the equality and tokenizer\u000a                return done([{value: newString.join('')}]);\u000a            }\u000a\u000a            // Main worker method. checks all permutations of a given edit length for acceptance.\u000a            function execEditLength() {\u000a                for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\u000a                    var basePath;\u000a                    var addPath = bestPath[diagonalPath - 1],\u000a                        removePath = bestPath[diagonalPath + 1],\u000a                        oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\u000a                    if (addPath) {\u000a                        // No one else is going to attempt to use this value, clear it\u000a                        bestPath[diagonalPath - 1] = undefined;\u000a                    }\u000a\u000a                    var canAdd = addPath && addPath.newPos + 1 < newLen,\u000a                        canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\u000a                    if (!canAdd && !canRemove) {\u000a                        // If this path is a terminal then prune\u000a                        bestPath[diagonalPath] = undefined;\u000a                        continue;\u000a                    }\u000a\u000a                    // Select the diagonal that we want to branch from. We select the prior\u000a                    // path whose position in the new string is the farthest from the origin\u000a                    // and does not pass the bounds of the diff graph\u000a                    if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\u000a                        basePath = clonePath(removePath);\u000a                        self.pushComponent(basePath.components, undefined, true);\u000a                    } else {\u000a                        basePath = addPath;   // No need to clone, we've pulled it from the list\u000a                        basePath.newPos++;\u000a                        self.pushComponent(basePath.components, true, undefined);\u000a                    }\u000a\u000a                    oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\u000a\u000a                    // If we have hit the end of both strings, then we are done\u000a                    if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\u000a                        return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\u000a                    } else {\u000a                        // Otherwise track this path as a potential candidate and continue.\u000a                        bestPath[diagonalPath] = basePath;\u000a                    }\u000a                }\u000a\u000a                editLength++;\u000a            }\u000a\u000a            // Performs the length of edit iteration. Is a bit fugly as this has to support the\u000a            // sync and async mode which is never fun. Loops over execEditLength until a value\u000a            // is produced.\u000a            if (callback) {\u000a                (function exec() {\u000a                    setTimeout(function() {\u000a                        // This should not happen, but we want to be safe.\u000a                        /*istanbul ignore next */\u000a                        if (editLength > maxEditLength) {\u000a                            return callback();\u000a                        }\u000a\u000a                        if (!execEditLength()) {\u000a                            exec();\u000a                        }\u000a                    }, 0);\u000a                }());\u000a            } else {\u000a                while (editLength <= maxEditLength) {\u000a                    var ret = execEditLength();\u000a                    if (ret) {\u000a                        return ret;\u000a                    }\u000a                }\u000a            }\u000a        },\u000a\u000a        pushComponent: function(components, added, removed) {\u000a            var last = components[components.length - 1];\u000a            if (last && last.added === added && last.removed === removed) {\u000a                // We need to clone here as the component clone operation is just\u000a                // as shallow array clone\u000a                components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\u000a            } else {\u000a                components.push({count: 1, added: added, removed: removed });\u000a            }\u000a        },\u000a        extractCommon: function(basePath, newString, oldString, diagonalPath) {\u000a            var newLen = newString.length,\u000a                oldLen = oldString.length,\u000a                newPos = basePath.newPos,\u000a                oldPos = newPos - diagonalPath,\u000a\u000a                commonCount = 0;\u000a            while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\u000a                newPos++;\u000a                oldPos++;\u000a                commonCount++;\u000a            }\u000a\u000a            if (commonCount) {\u000a                basePath.components.push({count: commonCount});\u000a            }\u000a\u000a            basePath.newPos = newPos;\u000a            return oldPos;\u000a        },\u000a\u000a        equals: function(left, right) {\u000a            var reWhitespace = /\u005cS/;\u000a            return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\u000a        },\u000a        tokenize: function(value) {\u000a            return value.split('');\u000a        }\u000a    };\u000a\u000a    var CharDiff = new Diff();\u000a\u000a    var WordDiff = new Diff(true);\u000a    var WordWithSpaceDiff = new Diff();\u000a    WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\u000a        return removeEmpty(value.split(/(\u005cs+|\u005cb)/));\u000a    };\u000a\u000a    var CssDiff = new Diff(true);\u000a    CssDiff.tokenize = function(value) {\u000a        return removeEmpty(value.split(/([{}:;,]|\u005cs+)/));\u000a    };\u000a\u000a    var LineDiff = new Diff();\u000a\u000a    var TrimmedLineDiff = new Diff();\u000a    TrimmedLineDiff.ignoreTrim = true;\u000a\u000a    LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\u000a        var retLines = [],\u000a            lines = value.split(/^/m);\u000a        for (var i = 0; i < lines.length; i++) {\u000a            var line = lines[i],\u000a                lastLine = lines[i - 1],\u000a                lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\u000a\u000a            // Merge lines that may contain windows new lines\u000a            if (line === '\u005cn' && lastLineLastChar === '\u005cr') {\u000a                retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\u005cr\u005cn';\u000a            } else {\u000a                if (this.ignoreTrim) {\u000a                    line = line.trim();\u000a                    // add a newline unless this is the last line.\u000a                    if (i < lines.length - 1) {\u000a                        line += '\u005cn';\u000a                    }\u000a                }\u000a                retLines.push(line);\u000a            }\u000a        }\u000a\u000a        return retLines;\u000a    };\u000a\u000a    var PatchDiff = new Diff();\u000a    PatchDiff.tokenize = function(value) {\u000a        var ret = [],\u000a            linesAndNewlines = value.split(/(\u005cn|\u005cr\u005cn)/);\u000a\u000a        // Ignore the final empty token that occurs if the string ends with a new line\u000a        if (!linesAndNewlines[linesAndNewlines.length - 1]) {\u000a            linesAndNewlines.pop();\u000a        }\u000a\u000a        // Merge the content and line separators into single tokens\u000a        for (var i = 0; i < linesAndNewlines.length; i++) {\u000a            var line = linesAndNewlines[i];\u000a\u000a            if (i % 2) {\u000a                ret[ret.length - 1] += line;\u000a            } else {\u000a                ret.push(line);\u000a            }\u000a        }\u000a        return ret;\u000a    };\u000a\u000a    var SentenceDiff = new Diff();\u000a    SentenceDiff.tokenize = function(value) {\u000a        return removeEmpty(value.split(/(\u005cS.+?[.!?])(?=\u005cs+|$)/));\u000a    };\u000a\u000a    var JsonDiff = new Diff();\u000a    // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\u000a    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\u000a    JsonDiff.useLongestToken = true;\u000a    JsonDiff.tokenize = LineDiff.tokenize;\u000a    JsonDiff.equals = function(left, right) {\u000a        return LineDiff.equals(left.replace(/,([\u005cr\u005cn])/g, '$1'), right.replace(/,([\u005cr\u005cn])/g, '$1'));\u000a    };\u000a\u000a    var JsDiff = {\u000a        Diff: Diff,\u000a\u000a        diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\u000a        diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\u000a        diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\u000a        diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\u000a        diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\u000a\u000a        diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\u000a\u000a        diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\u000a        diffJson: function(oldObj, newObj, callback) {\u000a            return JsonDiff.diff(\u000a                typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\u000a                typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\u000a                callback\u000a            );\u000a        },\u000a\u000a        createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\u000a            var ret = [];\u000a\u000a            if (oldFileName == newFileName) {\u000a                ret.push('Index: ' + oldFileName);\u000a            }\u000a            ret.push('===================================================================');\u000a            ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\u005ct' + oldHeader));\u000a            ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\u005ct' + newHeader));\u000a\u000a            var diff = PatchDiff.diff(oldStr, newStr);\u000a            diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\u000a\u000a            // Formats a given set of lines for printing as context lines in a patch\u000a            function contextLines(lines) {\u000a                return map(lines, function(entry) { return ' ' + entry; });\u000a            }\u000a\u000a            // Outputs the no newline at end of file warning if needed\u000a            function eofNL(curRange, i, current) {\u000a                var last = diff[diff.length - 2],\u000a                    isLast = i === diff.length - 2,\u000a                    isLastOfType = i === diff.length - 3 && current.added !== last.added;\u000a\u000a                // Figure out if this is the last line for the given file and missing NL\u000a                if (!(/\u005cn$/.test(current.value)) && (isLast || isLastOfType)) {\u000a                    curRange.push('\u005c\u005c No newline at end of file');\u000a                }\u000a            }\u000a\u000a            var oldRangeStart = 0, newRangeStart = 0, curRange = [],\u000a                oldLine = 1, newLine = 1;\u000a            for (var i = 0; i < diff.length; i++) {\u000a                var current = diff[i],\u000a                    lines = current.lines || current.value.replace(/\u005cn$/, '').split('\u005cn');\u000a                current.lines = lines;\u000a\u000a                if (current.added || current.removed) {\u000a                    // If we have previous context, start with that\u000a                    if (!oldRangeStart) {\u000a                        var prev = diff[i - 1];\u000a                        oldRangeStart = oldLine;\u000a                        newRangeStart = newLine;\u000a\u000a                        if (prev) {\u000a                            curRange = contextLines(prev.lines.slice(-4));\u000a                            oldRangeStart -= curRange.length;\u000a                            newRangeStart -= curRange.length;\u000a                        }\u000a                    }\u000a\u000a                    // Output our changes\u000a                    curRange.push.apply(curRange, map(lines, function(entry) {\u000a                        return (current.added ? '+' : '-') + entry;\u000a                    }));\u000a                    eofNL(curRange, i, current);\u000a\u000a                    // Track the updated file position\u000a                    if (current.added) {\u000a                        newLine += lines.length;\u000a                    } else {\u000a                        oldLine += lines.length;\u000a                    }\u000a                } else {\u000a                    // Identical context lines. Track line changes\u000a                    if (oldRangeStart) {\u000a                        // Close out any changes that have been output (or join overlapping)\u000a                        if (lines.length <= 8 && i < diff.length - 2) {\u000a                            // Overlapping\u000a                            curRange.push.apply(curRange, contextLines(lines));\u000a                        } else {\u000a                            // end the range and output\u000a                            var contextSize = Math.min(lines.length, 4);\u000a                            ret.push(\u000a                                '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\u000a                                + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\u000a                                + ' @@');\u000a                            ret.push.apply(ret, curRange);\u000a                            ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\u000a                            if (lines.length <= 4) {\u000a                                eofNL(ret, i, current);\u000a                            }\u000a\u000a                            oldRangeStart = 0;\u000a                            newRangeStart = 0;\u000a                            curRange = [];\u000a                        }\u000a                    }\u000a                    oldLine += lines.length;\u000a                    newLine += lines.length;\u000a                }\u000a            }\u000a\u000a            return ret.join('\u005cn') + '\u005cn';\u000a        },\u000a\u000a        createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\u000a            return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\u000a        },\u000a\u000a        applyPatch: function(oldStr, uniDiff) {\u000a            var diffstr = uniDiff.split('\u005cn'),\u000a                hunks = [],\u000a                i = 0,\u000a                remEOFNL = false,\u000a                addEOFNL = false;\u000a\u000a            // Skip to the first change hunk\u000a            while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\u000a                i++;\u000a            }\u000a\u000a            // Parse the unified diff\u000a            for (; i < diffstr.length; i++) {\u000a                if (diffstr[i][0] === '@') {\u000a                    var chnukHeader = diffstr[i].split(/@@ -(\u005cd+),(\u005cd+) \u005c+(\u005cd+),(\u005cd+) @@/);\u000a                    hunks.unshift({\u000a                        start: chnukHeader[3],\u000a                        oldlength: +chnukHeader[2],\u000a                        removed: [],\u000a                        newlength: chnukHeader[4],\u000a                        added: []\u000a                    });\u000a                } else if (diffstr[i][0] === '+') {\u000a                    hunks[0].added.push(diffstr[i].substr(1));\u000a                } else if (diffstr[i][0] === '-') {\u000a                    hunks[0].removed.push(diffstr[i].substr(1));\u000a                } else if (diffstr[i][0] === ' ') {\u000a                    hunks[0].added.push(diffstr[i].substr(1));\u000a                    hunks[0].removed.push(diffstr[i].substr(1));\u000a                } else if (diffstr[i][0] === '\u005c\u005c') {\u000a                    if (diffstr[i - 1][0] === '+') {\u000a                        remEOFNL = true;\u000a                    } else if (diffstr[i - 1][0] === '-') {\u000a                        addEOFNL = true;\u000a                    }\u000a                }\u000a            }\u000a\u000a            // Apply the diff to the input\u000a            var lines = oldStr.split('\u005cn');\u000a            for (i = hunks.length - 1; i >= 0; i--) {\u000a                var hunk = hunks[i];\u000a                // Sanity check the input string. Bail if we don't match.\u000a                for (var j = 0; j < hunk.oldlength; j++) {\u000a                    if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\u000a                        return false;\u000a                    }\u000a                }\u000a                Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\u000a            }\u000a\u000a            // Handle EOFNL insertion/removal\u000a            if (remEOFNL) {\u000a                while (!lines[lines.length - 1]) {\u000a                    lines.pop();\u000a                }\u000a            } else if (addEOFNL) {\u000a                lines.push('');\u000a            }\u000a            return lines.join('\u005cn');\u000a        },\u000a\u000a        convertChangesToXML: function(changes) {\u000a            var ret = [];\u000a            for (var i = 0; i < changes.length; i++) {\u000a                var change = changes[i];\u000a                if (change.added) {\u000a                    ret.push('<ins>');\u000a                } else if (change.removed) {\u000a                    ret.push('<del>');\u000a                }\u000a\u000a                ret.push(escapeHTML(change.value));\u000a\u000a                if (change.added) {\u000a                    ret.push('</ins>');\u000a                } else if (change.removed) {\u000a                    ret.push('</del>');\u000a                }\u000a            }\u000a            return ret.join('');\u000a        },\u000a\u000a        // See: http://code.google.com/p/google-diff-match-patch/wiki/API\u000a        convertChangesToDMP: function(changes) {\u000a            var ret = [],\u000a                change,\u000a                operation;\u000a            for (var i = 0; i < changes.length; i++) {\u000a                change = changes[i];\u000a                if (change.added) {\u000a                    operation = 1;\u000a                } else if (change.removed) {\u000a                    operation = -1;\u000a                } else {\u000a                    operation = 0;\u000a                }\u000a\u000a                ret.push([operation, change.value]);\u000a            }\u000a            return ret;\u000a        },\u000a\u000a        canonicalize: canonicalize\u000a    };\u000a\u000a    /*istanbul ignore next */\u000a    /*global module */\u000a    if (typeof module !== 'undefined' && module.exports) {\u000a        module.exports = JsDiff;\u000a    } else if (typeof define === 'function' && define.amd) {\u000a        /*global define */\u000a        define([], function() { return JsDiff; });\u000a    } else if (typeof global.JsDiff === 'undefined') {\u000a        global.JsDiff = JsDiff;\u000a    }\u000a}(this));\u000a\u000a;\u000a
p0
.